(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~eo-m~er-m~oa-o-i~om-o-i"],{

/***/ "./node_modules/react-json-editor-ajrm/es/err.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/err.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mitsuketa__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mitsuketa */ \"./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js\");\n/* harmony import */ var _mitsuketa__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mitsuketa__WEBPACK_IMPORTED_MODULE_0__);\n\nconst err = {\n  getCaller: (skip = 1) => {\n    // A somewhat hacky solution that will yield different results in different JS engines. \n    // Since we only call this function when an error will actually be thrown we typically don't \n    // rally mind the performance impact this might have if called too often.\n    // Lucky for us we use nodeJS and thus only V8.\n    const stackTrace = new Error().stack;\n    var callerName = stackTrace.replace(/^Error\\s+/, '');\n    callerName = callerName.split(\"\\n\")[skip];\n    callerName = callerName.replace(/^\\s+at Object./, '').replace(/^\\s+at /, '').replace(/ \\(.+\\)$/, '');\n    return callerName;\n  },\n  throwError: (fxName = 'unknown function', paramName = 'unknown parameter', expectation = 'to be defined') => {\n    throw ['@', fxName, '(): Expected parameter \\'', paramName, '\\' ', expectation].join('');\n  },\n  isUndefined: (paramName = '<unknown parameter>', param) => {\n    if ([null, undefined].indexOf(param) > -1) err.throwError(err.getCaller(2), paramName);\n  },\n  isFalsy: (paramName = '<unknown parameter>', param) => {\n    if (!param) err.throwError(err.getCaller(2), paramName);\n  },\n  isNoneOf: (paramName = '<unknown parameter>', param, contains = []) => {\n    if (contains.indexOf(param) === -1) err.throwError(err.getCaller(2), paramName, 'to be any of' + JSON.stringify(contains));\n  },\n  isAnyOf: (paramName = '<unknown parameter>', param, contains = []) => {\n    if (contains.indexOf(param) > -1) err.throwError(err.getCaller(2), paramName, 'not to be any of' + JSON.stringify(contains));\n  },\n  isNotType: (paramName = '<unknown parameter>', param, type = '') => {\n    if (Object(_mitsuketa__WEBPACK_IMPORTED_MODULE_0__[\"getType\"])(param) !== type.toLowerCase()) err.throwError(err.getCaller(2), paramName, 'to be type ' + type.toLowerCase());\n  },\n  isAnyTypeOf: (paramName = '<unknown parameter>', param, types = []) => {\n    types.forEach(type => {\n      if (Object(_mitsuketa__WEBPACK_IMPORTED_MODULE_0__[\"getType\"])(param) === type) err.throwError(err.getCaller(2), paramName, 'not to be type of ' + type.toLowerCase());\n    });\n  },\n  missingKey: (paramName = '<unknown parameter>', param, keyName = '') => {\n    err.isUndefined(paramName, param);\n    if (Object.keys(param).indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n  },\n  missingAnyKeys: (paramName = '<unknown parameter>', param, keyNames = ['']) => {\n    err.isUndefined(paramName, param);\n    const keyList = Object.keys(param);\n    keyNames.forEach(keyName => {\n      if (keyList.indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n    });\n  },\n  containsUndefined: (paramName = '<unknown parameter>', param) => {\n    [undefined, null].forEach(value => {\n      const location = Object(_mitsuketa__WEBPACK_IMPORTED_MODULE_0__[\"locate\"])(param, value);\n      if (location) err.throwError(err.getCaller(2), paramName, 'not to contain \\'' + JSON.stringify(value) + '\\' at ' + location);\n    });\n  },\n  isInvalidPath: (paramName = '<unknown parameter>', param) => {\n    err.isUndefined(paramName, param);\n    err.isNotType(paramName, param, 'string');\n    err.isAnyOf(paramName, param, ['', '/']);\n    '.$[]#'.split().forEach(invalidChar => {\n      if (param.indexOf(invalidChar) > -1) err.throwError(err.getCaller(2), paramName, 'not to contain invalid character \\'' + invalidChar + '\\'');\n    });\n    if (param.match(/\\/{2,}/g)) err.throwError(err.getCaller(2), paramName, 'not to contain consecutive forward slash characters');\n  },\n  isInvalidWriteData: (paramName = '<unknown parameter>', param) => {\n    err.isUndefined(paramName, param);\n    err.containsUndefined(paramName, param);\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (err);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9lcnIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9lcnIuanM/NjU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRUeXBlLCBsb2NhdGUgfSBmcm9tICcuL21pdHN1a2V0YSc7XG5jb25zdCBlcnIgPSB7XG4gIGdldENhbGxlcjogKHNraXAgPSAxKSA9PiB7XG4gICAgLy8gQSBzb21ld2hhdCBoYWNreSBzb2x1dGlvbiB0aGF0IHdpbGwgeWllbGQgZGlmZmVyZW50IHJlc3VsdHMgaW4gZGlmZmVyZW50IEpTIGVuZ2luZXMuIFxuICAgIC8vIFNpbmNlIHdlIG9ubHkgY2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4gYW4gZXJyb3Igd2lsbCBhY3R1YWxseSBiZSB0aHJvd24gd2UgdHlwaWNhbGx5IGRvbid0IFxuICAgIC8vIHJhbGx5IG1pbmQgdGhlIHBlcmZvcm1hbmNlIGltcGFjdCB0aGlzIG1pZ2h0IGhhdmUgaWYgY2FsbGVkIHRvbyBvZnRlbi5cbiAgICAvLyBMdWNreSBmb3IgdXMgd2UgdXNlIG5vZGVKUyBhbmQgdGh1cyBvbmx5IFY4LlxuICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB2YXIgY2FsbGVyTmFtZSA9IHN0YWNrVHJhY2UucmVwbGFjZSgvXkVycm9yXFxzKy8sICcnKTtcbiAgICBjYWxsZXJOYW1lID0gY2FsbGVyTmFtZS5zcGxpdChcIlxcblwiKVtza2lwXTtcbiAgICBjYWxsZXJOYW1lID0gY2FsbGVyTmFtZS5yZXBsYWNlKC9eXFxzK2F0IE9iamVjdC4vLCAnJykucmVwbGFjZSgvXlxccythdCAvLCAnJykucmVwbGFjZSgvIFxcKC4rXFwpJC8sICcnKTtcbiAgICByZXR1cm4gY2FsbGVyTmFtZTtcbiAgfSxcbiAgdGhyb3dFcnJvcjogKGZ4TmFtZSA9ICd1bmtub3duIGZ1bmN0aW9uJywgcGFyYW1OYW1lID0gJ3Vua25vd24gcGFyYW1ldGVyJywgZXhwZWN0YXRpb24gPSAndG8gYmUgZGVmaW5lZCcpID0+IHtcbiAgICB0aHJvdyBbJ0AnLCBmeE5hbWUsICcoKTogRXhwZWN0ZWQgcGFyYW1ldGVyIFxcJycsIHBhcmFtTmFtZSwgJ1xcJyAnLCBleHBlY3RhdGlvbl0uam9pbignJyk7XG4gIH0sXG4gIGlzVW5kZWZpbmVkOiAocGFyYW1OYW1lID0gJzx1bmtub3duIHBhcmFtZXRlcj4nLCBwYXJhbSkgPT4ge1xuICAgIGlmIChbbnVsbCwgdW5kZWZpbmVkXS5pbmRleE9mKHBhcmFtKSA+IC0xKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUpO1xuICB9LFxuICBpc0ZhbHN5OiAocGFyYW1OYW1lID0gJzx1bmtub3duIHBhcmFtZXRlcj4nLCBwYXJhbSkgPT4ge1xuICAgIGlmICghcGFyYW0pIGVyci50aHJvd0Vycm9yKGVyci5nZXRDYWxsZXIoMiksIHBhcmFtTmFtZSk7XG4gIH0sXG4gIGlzTm9uZU9mOiAocGFyYW1OYW1lID0gJzx1bmtub3duIHBhcmFtZXRlcj4nLCBwYXJhbSwgY29udGFpbnMgPSBbXSkgPT4ge1xuICAgIGlmIChjb250YWlucy5pbmRleE9mKHBhcmFtKSA9PT0gLTEpIGVyci50aHJvd0Vycm9yKGVyci5nZXRDYWxsZXIoMiksIHBhcmFtTmFtZSwgJ3RvIGJlIGFueSBvZicgKyBKU09OLnN0cmluZ2lmeShjb250YWlucykpO1xuICB9LFxuICBpc0FueU9mOiAocGFyYW1OYW1lID0gJzx1bmtub3duIHBhcmFtZXRlcj4nLCBwYXJhbSwgY29udGFpbnMgPSBbXSkgPT4ge1xuICAgIGlmIChjb250YWlucy5pbmRleE9mKHBhcmFtKSA+IC0xKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICdub3QgdG8gYmUgYW55IG9mJyArIEpTT04uc3RyaW5naWZ5KGNvbnRhaW5zKSk7XG4gIH0sXG4gIGlzTm90VHlwZTogKHBhcmFtTmFtZSA9ICc8dW5rbm93biBwYXJhbWV0ZXI+JywgcGFyYW0sIHR5cGUgPSAnJykgPT4ge1xuICAgIGlmIChnZXRUeXBlKHBhcmFtKSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICd0byBiZSB0eXBlICcgKyB0eXBlLnRvTG93ZXJDYXNlKCkpO1xuICB9LFxuICBpc0FueVR5cGVPZjogKHBhcmFtTmFtZSA9ICc8dW5rbm93biBwYXJhbWV0ZXI+JywgcGFyYW0sIHR5cGVzID0gW10pID0+IHtcbiAgICB0eXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgaWYgKGdldFR5cGUocGFyYW0pID09PSB0eXBlKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICdub3QgdG8gYmUgdHlwZSBvZiAnICsgdHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9KTtcbiAgfSxcbiAgbWlzc2luZ0tleTogKHBhcmFtTmFtZSA9ICc8dW5rbm93biBwYXJhbWV0ZXI+JywgcGFyYW0sIGtleU5hbWUgPSAnJykgPT4ge1xuICAgIGVyci5pc1VuZGVmaW5lZChwYXJhbU5hbWUsIHBhcmFtKTtcbiAgICBpZiAoT2JqZWN0LmtleXMocGFyYW0pLmluZGV4T2Yoa2V5TmFtZSkgPT09IC0xKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICd0byBjb250YWluIFxcJycgKyBrZXlOYW1lICsgJ1xcJyBrZXknKTtcbiAgfSxcbiAgbWlzc2luZ0FueUtleXM6IChwYXJhbU5hbWUgPSAnPHVua25vd24gcGFyYW1ldGVyPicsIHBhcmFtLCBrZXlOYW1lcyA9IFsnJ10pID0+IHtcbiAgICBlcnIuaXNVbmRlZmluZWQocGFyYW1OYW1lLCBwYXJhbSk7XG4gICAgY29uc3Qga2V5TGlzdCA9IE9iamVjdC5rZXlzKHBhcmFtKTtcbiAgICBrZXlOYW1lcy5mb3JFYWNoKGtleU5hbWUgPT4ge1xuICAgICAgaWYgKGtleUxpc3QuaW5kZXhPZihrZXlOYW1lKSA9PT0gLTEpIGVyci50aHJvd0Vycm9yKGVyci5nZXRDYWxsZXIoMiksIHBhcmFtTmFtZSwgJ3RvIGNvbnRhaW4gXFwnJyArIGtleU5hbWUgKyAnXFwnIGtleScpO1xuICAgIH0pO1xuICB9LFxuICBjb250YWluc1VuZGVmaW5lZDogKHBhcmFtTmFtZSA9ICc8dW5rbm93biBwYXJhbWV0ZXI+JywgcGFyYW0pID0+IHtcbiAgICBbdW5kZWZpbmVkLCBudWxsXS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gbG9jYXRlKHBhcmFtLCB2YWx1ZSk7XG4gICAgICBpZiAobG9jYXRpb24pIGVyci50aHJvd0Vycm9yKGVyci5nZXRDYWxsZXIoMiksIHBhcmFtTmFtZSwgJ25vdCB0byBjb250YWluIFxcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnXFwnIGF0ICcgKyBsb2NhdGlvbik7XG4gICAgfSk7XG4gIH0sXG4gIGlzSW52YWxpZFBhdGg6IChwYXJhbU5hbWUgPSAnPHVua25vd24gcGFyYW1ldGVyPicsIHBhcmFtKSA9PiB7XG4gICAgZXJyLmlzVW5kZWZpbmVkKHBhcmFtTmFtZSwgcGFyYW0pO1xuICAgIGVyci5pc05vdFR5cGUocGFyYW1OYW1lLCBwYXJhbSwgJ3N0cmluZycpO1xuICAgIGVyci5pc0FueU9mKHBhcmFtTmFtZSwgcGFyYW0sIFsnJywgJy8nXSk7XG4gICAgJy4kW10jJy5zcGxpdCgpLmZvckVhY2goaW52YWxpZENoYXIgPT4ge1xuICAgICAgaWYgKHBhcmFtLmluZGV4T2YoaW52YWxpZENoYXIpID4gLTEpIGVyci50aHJvd0Vycm9yKGVyci5nZXRDYWxsZXIoMiksIHBhcmFtTmFtZSwgJ25vdCB0byBjb250YWluIGludmFsaWQgY2hhcmFjdGVyIFxcJycgKyBpbnZhbGlkQ2hhciArICdcXCcnKTtcbiAgICB9KTtcbiAgICBpZiAocGFyYW0ubWF0Y2goL1xcL3syLH0vZykpIGVyci50aHJvd0Vycm9yKGVyci5nZXRDYWxsZXIoMiksIHBhcmFtTmFtZSwgJ25vdCB0byBjb250YWluIGNvbnNlY3V0aXZlIGZvcndhcmQgc2xhc2ggY2hhcmFjdGVycycpO1xuICB9LFxuICBpc0ludmFsaWRXcml0ZURhdGE6IChwYXJhbU5hbWUgPSAnPHVua25vd24gcGFyYW1ldGVyPicsIHBhcmFtKSA9PiB7XG4gICAgZXJyLmlzVW5kZWZpbmVkKHBhcmFtTmFtZSwgcGFyYW0pO1xuICAgIGVyci5jb250YWluc1VuZGVmaW5lZChwYXJhbU5hbWUsIHBhcmFtKTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGVycjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/es/err.js\n");

/***/ }),

/***/ "./node_modules/react-json-editor-ajrm/es/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/index.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread */ \"./node_modules/react-json-editor-ajrm/node_modules/@babel/runtime/helpers/esm/objectSpread.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _themes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./themes */ \"./node_modules/react-json-editor-ajrm/es/themes.js\");\n/* harmony import */ var _mitsuketa__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mitsuketa */ \"./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js\");\n/* harmony import */ var _mitsuketa__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_mitsuketa__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _err__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./err */ \"./node_modules/react-json-editor-ajrm/es/err.js\");\n/* harmony import */ var _locale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./locale */ \"./node_modules/react-json-editor-ajrm/es/locale/index.js\");\n/* harmony import */ var _locale_en__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./locale/en */ \"./node_modules/react-json-editor-ajrm/es/locale/en.js\");\n/** @license react-json-editor-ajrm v2.5.9\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\nclass JSONInput extends react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"] {\n  constructor(props) {\n    super(props);\n    this.updateInternalProps = this.updateInternalProps.bind(this);\n    this.createMarkup = this.createMarkup.bind(this);\n    this.onClick = this.onClick.bind(this);\n    this.onBlur = this.onBlur.bind(this);\n    this.update = this.update.bind(this);\n    this.getCursorPosition = this.getCursorPosition.bind(this);\n    this.setCursorPosition = this.setCursorPosition.bind(this);\n    this.scheduledUpdate = this.scheduledUpdate.bind(this);\n    this.setUpdateTime = this.setUpdateTime.bind(this);\n    this.renderLabels = this.renderLabels.bind(this);\n    this.newSpan = this.newSpan.bind(this);\n    this.renderErrorMessage = this.renderErrorMessage.bind(this);\n    this.onScroll = this.onScroll.bind(this);\n    this.showPlaceholder = this.showPlaceholder.bind(this);\n    this.tokenize = this.tokenize.bind(this);\n    this.onKeyPress = this.onKeyPress.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.onPaste = this.onPaste.bind(this);\n    this.stopEvent = this.stopEvent.bind(this);\n    this.refContent = null;\n    this.refLabels = null;\n    this.updateInternalProps();\n    this.renderCount = 1;\n    this.state = {\n      prevPlaceholder: '',\n      markupText: '',\n      plainText: '',\n      json: '',\n      jsObject: undefined,\n      lines: false,\n      error: false\n    };\n\n    if (!this.props.locale) {\n      console.warn(\"[react-json-editor-ajrm - Deprecation Warning] You did not provide a 'locale' prop for your JSON input - This will be required in a future version. English has been set as a default.\");\n    }\n  }\n\n  updateInternalProps() {\n    let colors = {},\n        style = {},\n        theme = _themes__WEBPACK_IMPORTED_MODULE_2__[\"default\"].dark_vscode_tribute;\n    if ('theme' in this.props) if (typeof this.props.theme === 'string') if (this.props.theme in _themes__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) theme = _themes__WEBPACK_IMPORTED_MODULE_2__[\"default\"][this.props.theme];\n    colors = theme;\n    if ('colors' in this.props) colors = {\n      default: 'default' in this.props.colors ? this.props.colors.default : colors.default,\n      string: 'string' in this.props.colors ? this.props.colors.string : colors.string,\n      number: 'number' in this.props.colors ? this.props.colors.number : colors.number,\n      colon: 'colon' in this.props.colors ? this.props.colors.colon : colors.colon,\n      keys: 'keys' in this.props.colors ? this.props.colors.keys : colors.keys,\n      keys_whiteSpace: 'keys_whiteSpace' in this.props.colors ? this.props.colors.keys_whiteSpace : colors.keys_whiteSpace,\n      primitive: 'primitive' in this.props.colors ? this.props.colors.primitive : colors.primitive,\n      error: 'error' in this.props.colors ? this.props.colors.error : colors.error,\n      background: 'background' in this.props.colors ? this.props.colors.background : colors.background,\n      background_warning: 'background_warning' in this.props.colors ? this.props.colors.background_warning : colors.background_warning\n    };\n    this.colors = colors;\n    if ('style' in this.props) style = {\n      outerBox: 'outerBox' in this.props.style ? this.props.style.outerBox : {},\n      container: 'container' in this.props.style ? this.props.style.container : {},\n      warningBox: 'warningBox' in this.props.style ? this.props.style.warningBox : {},\n      errorMessage: 'errorMessage' in this.props.style ? this.props.style.errorMessage : {},\n      body: 'body' in this.props.style ? this.props.style.body : {},\n      labelColumn: 'labelColumn' in this.props.style ? this.props.style.labelColumn : {},\n      labels: 'labels' in this.props.style ? this.props.style.labels : {},\n      contentBox: 'contentBox' in this.props.style ? this.props.style.contentBox : {}\n    };else style = {\n      outerBox: {},\n      container: {},\n      warningBox: {},\n      errorMessage: {},\n      body: {},\n      labelColumn: {},\n      labels: {},\n      contentBox: {}\n    };\n    this.style = style;\n    this.confirmGood = 'confirmGood' in this.props ? this.props.confirmGood : true;\n    const totalHeight = this.props.height || '610px',\n          totalWidth = this.props.width || '479px';\n    this.totalHeight = totalHeight;\n    this.totalWidth = totalWidth;\n\n    if (!('onKeyPressUpdate' in this.props) || this.props.onKeyPressUpdate) {\n      if (!this.timer) this.timer = setInterval(this.scheduledUpdate, 100);\n    } else if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = false;\n    }\n\n    this.updateTime = false;\n    this.waitAfterKeyPress = 'waitAfterKeyPress' in this.props ? this.props.waitAfterKeyPress : 1000;\n    this.resetConfiguration = 'reset' in this.props ? this.props.reset : false;\n  }\n\n  render() {\n    const id = this.props.id,\n          markupText = this.state.markupText,\n          error = this.state.error,\n          colors = this.colors,\n          style = this.style,\n          confirmGood = this.confirmGood,\n          totalHeight = this.totalHeight,\n          totalWidth = this.totalWidth,\n          hasError = error ? 'token' in error : false;\n    this.renderCount++;\n    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"div\", {\n      name: \"outer-box\",\n      id: id && id + '-outer-box',\n      style: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'block',\n        overflow: 'none',\n        height: totalHeight,\n        width: totalWidth,\n        margin: 0,\n        boxSizing: 'border-box',\n        position: 'relative'\n      }, style.outerBox)\n    }, confirmGood ? react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"div\", {\n      style: {\n        opacity: hasError ? 0 : 1,\n        height: '30px',\n        width: '30px',\n        position: 'absolute',\n        top: 0,\n        right: 0,\n        transform: 'translate(-25%,25%)',\n        pointerEvents: 'none',\n        transitionDuration: '0.2s',\n        transitionTimingFunction: 'cubic-bezier(0, 1, 0.5, 1)'\n      }\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"svg\", {\n      height: \"30px\",\n      width: \"30px\",\n      viewBox: \"0 0 100 100\"\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      fill: \"green\",\n      opacity: \"0.85\",\n      d: \"M39.363,79L16,55.49l11.347-11.419L39.694,56.49L72.983,23L84,34.085L39.363,79z\"\n    }))) : void 0, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"div\", {\n      name: \"container\",\n      id: id && id + '-container',\n      style: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'block',\n        height: totalHeight,\n        width: totalWidth,\n        margin: 0,\n        boxSizing: 'border-box',\n        overflow: 'hidden',\n        fontFamily: 'Roboto, sans-serif'\n      }, style.container),\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"div\", {\n      name: \"warning-box\",\n      id: id && id + '-warning-box',\n      style: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'block',\n        overflow: 'hidden',\n        height: hasError ? '60px' : '0px',\n        width: '100%',\n        margin: 0,\n        backgroundColor: colors.background_warning,\n        transitionDuration: '0.2s',\n        transitionTimingFunction: 'cubic-bezier(0, 1, 0.5, 1)'\n      }, style.warningBox),\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"span\", {\n      style: {\n        display: 'inline-block',\n        height: '60px',\n        width: '60px',\n        margin: 0,\n        boxSizing: 'border-box',\n        overflow: 'hidden',\n        verticalAlign: 'top',\n        pointerEvents: 'none'\n      },\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"div\", {\n      style: {\n        position: 'relative',\n        top: 0,\n        left: 0,\n        height: '60px',\n        width: '60px',\n        margin: 0,\n        pointerEvents: 'none'\n      },\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"div\", {\n      style: {\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        transform: 'translate(-50%, -50%)',\n        pointerEvents: 'none'\n      },\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"svg\", {\n      height: \"25px\",\n      width: \"25px\",\n      viewBox: \"0 0 100 100\"\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      fill: \"red\",\n      d: \"M73.9,5.75c0.467-0.467,1.067-0.7,1.8-0.7c0.7,0,1.283,0.233,1.75,0.7l16.8,16.8  c0.467,0.5,0.7,1.084,0.7,1.75c0,0.733-0.233,1.334-0.7,1.801L70.35,50l23.9,23.95c0.5,0.467,0.75,1.066,0.75,1.8  c0,0.667-0.25,1.25-0.75,1.75l-16.8,16.75c-0.534,0.467-1.117,0.7-1.75,0.7s-1.233-0.233-1.8-0.7L50,70.351L26.1,94.25  c-0.567,0.467-1.167,0.7-1.8,0.7c-0.667,0-1.283-0.233-1.85-0.7L5.75,77.5C5.25,77,5,76.417,5,75.75c0-0.733,0.25-1.333,0.75-1.8  L29.65,50L5.75,26.101C5.25,25.667,5,25.066,5,24.3c0-0.666,0.25-1.25,0.75-1.75l16.8-16.8c0.467-0.467,1.05-0.7,1.75-0.7  c0.733,0,1.333,0.233,1.8,0.7L50,29.65L73.9,5.75z\"\n    }))))), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"span\", {\n      style: {\n        display: 'inline-block',\n        height: '60px',\n        width: 'calc(100% - 60px)',\n        margin: 0,\n        overflow: 'hidden',\n        verticalAlign: 'top',\n        position: 'absolute',\n        pointerEvents: 'none'\n      },\n      onClick: this.onClick\n    }, this.renderErrorMessage())), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"div\", {\n      name: \"body\",\n      id: id && id + '-body',\n      style: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'flex',\n        overflow: 'none',\n        height: hasError ? 'calc(100% - 60px)' : '100%',\n        width: '',\n        margin: 0,\n        resize: 'none',\n        fontFamily: 'Roboto Mono, Monaco, monospace',\n        fontSize: '11px',\n        backgroundColor: colors.background,\n        transitionDuration: '0.2s',\n        transitionTimingFunction: 'cubic-bezier(0, 1, 0.5, 1)'\n      }, style.body),\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"span\", {\n      name: \"labels\",\n      id: id && id + '-labels',\n      ref: ref => this.refLabels = ref,\n      style: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'inline-block',\n        boxSizing: 'border-box',\n        verticalAlign: 'top',\n        height: '100%',\n        width: '44px',\n        margin: 0,\n        padding: '5px 0px 5px 10px',\n        overflow: 'hidden',\n        color: '#D4D4D4'\n      }, style.labelColumn),\n      onClick: this.onClick\n    }, this.renderLabels()), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"span\", {\n      id: id,\n      ref: ref => this.refContent = ref,\n      contentEditable: true,\n      style: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'inline-block',\n        boxSizing: 'border-box',\n        verticalAlign: 'top',\n        height: '100%',\n        width: '',\n        flex: 1,\n        margin: 0,\n        padding: '5px',\n        overflowX: 'hidden',\n        overflowY: 'auto',\n        wordWrap: 'break-word',\n        whiteSpace: 'pre-line',\n        color: '#D4D4D4',\n        outline: 'none'\n      }, style.contentBox),\n      dangerouslySetInnerHTML: this.createMarkup(markupText),\n      onKeyPress: this.onKeyPress,\n      onKeyDown: this.onKeyDown,\n      onClick: this.onClick,\n      onBlur: this.onBlur,\n      onScroll: this.onScroll,\n      onPaste: this.onPaste,\n      autoComplete: \"off\",\n      autoCorrect: \"off\",\n      autoCapitalize: \"off\",\n      spellCheck: false\n    }))));\n  }\n\n  renderErrorMessage() {\n    const locale = this.props.locale || _locale_en__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n          error = this.state.error,\n          style = this.style;\n    if (!error) return void 0;\n    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"p\", {\n      style: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        color: 'red',\n        fontSize: '12px',\n        position: 'absolute',\n        width: 'calc(100% - 60px)',\n        height: '60px',\n        boxSizing: 'border-box',\n        margin: 0,\n        padding: 0,\n        paddingRight: '10px',\n        overflowWrap: 'break-word',\n        display: 'flex',\n        flexDirection: 'column',\n        justifyContent: 'center'\n      }, style.errorMessage)\n    }, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.format, error));\n  }\n\n  renderLabels() {\n    const colors = this.colors,\n          style = this.style,\n          errorLine = this.state.error ? this.state.error.line : -1,\n          lines = this.state.lines ? this.state.lines : 1;\n    let labels = new Array(lines);\n\n    for (var i = 0; i < lines - 1; i++) labels[i] = i + 1;\n\n    return labels.map(number => {\n      const color = number !== errorLine ? colors.default : 'red';\n      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\"div\", {\n        key: number,\n        style: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, style.labels, {\n          color: color\n        })\n      }, number);\n    });\n  }\n\n  createMarkup(markupText) {\n    if (markupText === undefined) return {\n      __html: ''\n    };\n    return {\n      __html: '' + markupText\n    };\n  }\n\n  newSpan(i, token, depth) {\n    let colors = this.colors,\n        type = token.type,\n        string = token.string;\n    let color = '';\n\n    switch (type) {\n      case 'string':\n      case 'number':\n      case 'primitive':\n      case 'error':\n        color = colors[token.type];\n        break;\n\n      case 'key':\n        if (string === ' ') color = colors.keys_whiteSpace;else color = colors.keys;\n        break;\n\n      case 'symbol':\n        if (string === ':') color = colors.colon;else color = colors.default;\n        break;\n\n      default:\n        color = colors.default;\n        break;\n    }\n\n    if (string.length !== string.replace(/</g, '').replace(/>/g, '').length) string = '<xmp style=display:inline;>' + string + '</xmp>';\n    return '<span' + ' type=\"' + type + '\"' + ' value=\"' + string + '\"' + ' depth=\"' + depth + '\"' + ' style=\"color:' + color + '\"' + '>' + string + '</span>';\n  }\n\n  getCursorPosition(countBR) {\n    /**\r\n     * Need to deprecate countBR\r\n     * It is used to differenciate between good markup render, and aux render when error found\r\n     * Adjustments based on coundBR account for usage of <br> instead of <span> for linebreaks to determine acurate cursor position\r\n     * Find a way to consolidate render styles\r\n     */\n    const isChildOf = node => {\n      while (node !== null) {\n        if (node === this.refContent) return true;\n        node = node.parentNode;\n      }\n\n      return false;\n    };\n\n    let selection = window.getSelection(),\n        charCount = -1,\n        linebreakCount = 0,\n        node;\n\n    if (selection.focusNode && isChildOf(selection.focusNode)) {\n      node = selection.focusNode;\n      charCount = selection.focusOffset;\n\n      while (node) {\n        if (node === this.refContent) break;\n\n        if (node.previousSibling) {\n          node = node.previousSibling;\n          if (countBR) if (node.nodeName === 'BR') linebreakCount++;\n          charCount += node.textContent.length;\n        } else {\n          node = node.parentNode;\n          if (node === null) break;\n        }\n      }\n    }\n\n    return charCount + linebreakCount;\n  }\n\n  setCursorPosition(nextPosition) {\n    if ([false, null, undefined].indexOf(nextPosition) > -1) return;\n\n    const createRange = (node, chars, range) => {\n      if (!range) {\n        range = document.createRange();\n        range.selectNode(node);\n        range.setStart(node, 0);\n      }\n\n      if (chars.count === 0) {\n        range.setEnd(node, chars.count);\n      } else if (node && chars.count > 0) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          if (node.textContent.length < chars.count) chars.count -= node.textContent.length;else {\n            range.setEnd(node, chars.count);\n            chars.count = 0;\n          }\n        } else for (var lp = 0; lp < node.childNodes.length; lp++) {\n          range = createRange(node.childNodes[lp], chars, range);\n          if (chars.count === 0) break;\n        }\n      }\n\n      return range;\n    };\n\n    const setPosition = chars => {\n      if (chars < 0) return;\n      let selection = window.getSelection(),\n          range = createRange(this.refContent, {\n        count: chars\n      });\n      if (!range) return;\n      range.collapse(false);\n      selection.removeAllRanges();\n      selection.addRange(range);\n    };\n\n    if (nextPosition > 0) setPosition(nextPosition);else this.refContent.focus();\n  }\n\n  update(cursorOffset = 0, updateCursorPosition = true) {\n    const container = this.refContent,\n          data = this.tokenize(container);\n    if ('onChange' in this.props) this.props.onChange({\n      plainText: data.indented,\n      markupText: data.markup,\n      json: data.json,\n      jsObject: data.jsObject,\n      lines: data.lines,\n      error: data.error\n    });\n    let cursorPosition = this.getCursorPosition(data.error) + cursorOffset;\n    this.setState({\n      plainText: data.indented,\n      markupText: data.markup,\n      json: data.json,\n      jsObject: data.jsObject,\n      lines: data.lines,\n      error: data.error\n    });\n    this.updateTime = false;\n    if (updateCursorPosition) this.setCursorPosition(cursorPosition);\n  }\n\n  scheduledUpdate() {\n    if ('onKeyPressUpdate' in this.props) if (this.props.onKeyPressUpdate === false) return;\n    const {\n      updateTime\n    } = this;\n    if (updateTime === false) return;\n    if (updateTime > new Date().getTime()) return;\n    this.update();\n  }\n\n  setUpdateTime() {\n    if ('onKeyPressUpdate' in this.props) if (this.props.onKeyPressUpdate === false) return;\n    this.updateTime = new Date().getTime() + this.waitAfterKeyPress;\n  }\n\n  stopEvent(event) {\n    if (!event) return;\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  onKeyPress(event) {\n    const ctrlOrMetaIsPressed = event.ctrlKey || event.metaKey;\n    if (this.props.viewOnly && !ctrlOrMetaIsPressed) this.stopEvent(event);\n    if (!ctrlOrMetaIsPressed) this.setUpdateTime();\n  }\n\n  onKeyDown(event) {\n    const viewOnly = !!this.props.viewOnly;\n    const ctrlOrMetaIsPressed = event.ctrlKey || event.metaKey;\n\n    switch (event.key) {\n      case 'Tab':\n        this.stopEvent(event);\n        if (viewOnly) break;\n        document.execCommand(\"insertText\", false, \"  \");\n        this.setUpdateTime();\n        break;\n\n      case 'Backspace':\n      case 'Delete':\n        if (viewOnly) this.stopEvent(event);\n        this.setUpdateTime();\n        break;\n\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'ArrowUp':\n      case 'ArrowDown':\n        this.setUpdateTime();\n        break;\n\n      case 'a':\n      case 'c':\n        if (viewOnly && !ctrlOrMetaIsPressed) this.stopEvent(event);\n        break;\n\n      default:\n        if (viewOnly) this.stopEvent(event);\n        break;\n    }\n  }\n\n  onPaste(event) {\n    if (this.props.viewOnly) {\n      this.stopEvent(event);\n    } else {\n      event.preventDefault();\n      var text = event.clipboardData.getData('text/plain');\n      document.execCommand('insertHTML', false, text);\n    }\n\n    this.update();\n  }\n\n  onClick() {\n    if ('viewOnly' in this.props) if (this.props.viewOnly) return;\n  }\n\n  onBlur() {\n    if ('viewOnly' in this.props) if (this.props.viewOnly) return;\n    this.update(0, false);\n  }\n\n  onScroll(event) {\n    this.refLabels.scrollTop = event.target.scrollTop;\n  }\n\n  componentDidUpdate() {\n    this.updateInternalProps();\n    this.showPlaceholder();\n  }\n\n  componentDidMount() {\n    this.showPlaceholder();\n  }\n\n  componentWillUnmount() {\n    if (this.timer) clearInterval(this.timer);\n  }\n\n  showPlaceholder() {\n    const placeholderDoesNotExist = !('placeholder' in this.props);\n    if (placeholderDoesNotExist) return;\n    const {\n      placeholder\n    } = this.props;\n    const placeholderHasEmptyValues = [undefined, null].indexOf(placeholder) > -1;\n    if (placeholderHasEmptyValues) return;\n    const {\n      prevPlaceholder,\n      jsObject\n    } = this.state;\n    const {\n      resetConfiguration\n    } = this;\n    const placeholderDataType = Object(_mitsuketa__WEBPACK_IMPORTED_MODULE_3__[\"getType\"])(placeholder);\n    const unexpectedDataType = ['object', 'array'].indexOf(placeholderDataType) === -1;\n    if (unexpectedDataType) _err__WEBPACK_IMPORTED_MODULE_4__[\"default\"].throwError('showPlaceholder', 'placeholder', 'either an object or an array');\n    const samePlaceholderValues = Object(_mitsuketa__WEBPACK_IMPORTED_MODULE_3__[\"identical\"])(placeholder, prevPlaceholder); // Component will always re-render when new placeholder value is any different from previous placeholder value. \n\n    let componentShouldUpdate = !samePlaceholderValues;\n\n    if (!componentShouldUpdate) {\n      if (resetConfiguration) {\n        /**\r\n         * If 'reset' property is set true or is truthy,\r\n         * any difference between placeholder and current value\r\n         * should trigger component re-render\r\n         */\n        if (jsObject !== undefined) componentShouldUpdate = !Object(_mitsuketa__WEBPACK_IMPORTED_MODULE_3__[\"identical\"])(placeholder, jsObject);\n      }\n    }\n\n    if (!componentShouldUpdate) return;\n    const data = this.tokenize(placeholder);\n    this.setState({\n      prevPlaceholder: placeholder,\n      plainText: data.indentation,\n      markupText: data.markup,\n      lines: data.lines,\n      error: data.error\n    });\n  }\n\n  tokenize(something) {\n    if (typeof something !== 'object') return console.error('tokenize() expects object type properties only. Got \\'' + typeof something + '\\' type instead.');\n    const locale = this.props.locale || _locale_en__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n    const newSpan = this.newSpan;\n    /**\r\n     *     DOM NODE || ONBLUR OR UPDATE\r\n     */\n\n    if ('nodeType' in something) {\n      const containerNode = something.cloneNode(true),\n            hasChildren = containerNode.hasChildNodes();\n      if (!hasChildren) return '';\n      const children = containerNode.childNodes;\n      let buffer = {\n        tokens_unknown: [],\n        tokens_proto: [],\n        tokens_split: [],\n        tokens_fallback: [],\n        tokens_normalize: [],\n        tokens_merge: [],\n        tokens_plainText: '',\n        indented: '',\n        json: '',\n        jsObject: undefined,\n        markup: ''\n      };\n\n      for (var i = 0; i < children.length; i++) {\n        let child = children[i];\n        let info = {};\n\n        switch (child.nodeName) {\n          case 'SPAN':\n            info = {\n              string: child.textContent,\n              type: child.attributes.type.textContent\n            };\n            buffer.tokens_unknown.push(info);\n            break;\n\n          case 'DIV':\n            buffer.tokens_unknown.push({\n              string: child.textContent,\n              type: 'unknown'\n            });\n            break;\n\n          case 'BR':\n            if (child.textContent === '') buffer.tokens_unknown.push({\n              string: '\\n',\n              type: 'unknown'\n            });\n            break;\n\n          case '#text':\n            buffer.tokens_unknown.push({\n              string: child.wholeText,\n              type: 'unknown'\n            });\n            break;\n\n          case 'FONT':\n            buffer.tokens_unknown.push({\n              string: child.textContent,\n              type: 'unknown'\n            });\n            break;\n\n          default:\n            console.error('Unrecognized node:', {\n              child\n            });\n            break;\n        }\n      }\n\n      function quarkize(text, prefix = '') {\n        let buffer = {\n          active: false,\n          string: '',\n          number: '',\n          symbol: '',\n          space: '',\n          delimiter: '',\n          quarks: []\n        };\n\n        function pushAndStore(char, type) {\n          switch (type) {\n            case 'symbol':\n            case 'delimiter':\n              if (buffer.active) buffer.quarks.push({\n                string: buffer[buffer.active],\n                type: prefix + '-' + buffer.active\n              });\n              buffer[buffer.active] = '';\n              buffer.active = type;\n              buffer[buffer.active] = char;\n              break;\n\n            default:\n              if (type !== buffer.active || [buffer.string, char].indexOf('\\n') > -1) {\n                if (buffer.active) buffer.quarks.push({\n                  string: buffer[buffer.active],\n                  type: prefix + '-' + buffer.active\n                });\n                buffer[buffer.active] = '';\n                buffer.active = type;\n                buffer[buffer.active] = char;\n              } else buffer[type] += char;\n\n              break;\n          }\n        }\n\n        function finalPush() {\n          if (buffer.active) {\n            buffer.quarks.push({\n              string: buffer[buffer.active],\n              type: prefix + '-' + buffer.active\n            });\n            buffer[buffer.active] = '';\n            buffer.active = false;\n          }\n        }\n\n        for (var i = 0; i < text.length; i++) {\n          const char = text.charAt(i);\n\n          switch (char) {\n            case '\"':\n            case \"'\":\n              pushAndStore(char, 'delimiter');\n              break;\n\n            case ' ':\n            case '\\u00A0':\n              pushAndStore(char, 'space');\n              break;\n\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n              pushAndStore(char, 'symbol');\n              break;\n\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n              if (buffer.active === 'string') pushAndStore(char, 'string');else pushAndStore(char, 'number');\n              break;\n\n            case '-':\n              if (i < text.length - 1) if ('0123456789'.indexOf(text.charAt(i + 1)) > -1) {\n                pushAndStore(char, 'number');\n                break;\n              }\n\n            case '.':\n              if (i < text.length - 1 && i > 0) if ('0123456789'.indexOf(text.charAt(i + 1)) > -1 && '0123456789'.indexOf(text.charAt(i - 1)) > -1) {\n                pushAndStore(char, 'number');\n                break;\n              }\n\n            default:\n              pushAndStore(char, 'string');\n              break;\n          }\n        }\n\n        finalPush();\n        return buffer.quarks;\n      }\n\n      for (var i = 0; i < buffer.tokens_unknown.length; i++) {\n        let token = buffer.tokens_unknown[i];\n        buffer.tokens_proto = buffer.tokens_proto.concat(quarkize(token.string, 'proto'));\n      }\n\n      function validToken(string, type) {\n        const quotes = '\\'\"';\n        let firstChar = '',\n            lastChar = '',\n            quoteType = false;\n\n        switch (type) {\n          case 'primitive':\n            if (['true', 'false', 'null', 'undefined'].indexOf(string) === -1) return false;\n            break;\n\n          case 'string':\n            if (string.length < 2) return false;\n            firstChar = string.charAt(0), lastChar = string.charAt(string.length - 1), quoteType = quotes.indexOf(firstChar);\n            if (quoteType === -1) return false;\n            if (firstChar !== lastChar) return false;\n\n            for (var i = 0; i < string.length; i++) {\n              if (i > 0 && i < string.length - 1) if (string.charAt(i) === quotes[quoteType]) if (string.charAt(i - 1) !== '\\\\') return false;\n            }\n\n            break;\n\n          case 'key':\n            if (string.length === 0) return false;\n            firstChar = string.charAt(0), lastChar = string.charAt(string.length - 1), quoteType = quotes.indexOf(firstChar);\n\n            if (quoteType > -1) {\n              if (string.length === 1) return false;\n              if (firstChar !== lastChar) return false;\n\n              for (var i = 0; i < string.length; i++) {\n                if (i > 0 && i < string.length - 1) if (string.charAt(i) === quotes[quoteType]) if (string.charAt(i - 1) !== '\\\\') return false;\n              }\n            } else {\n              const nonAlphanumeric = '\\'\"`.,:;{}[]&<>=~*%\\\\|/-+!?@^ \\xa0';\n\n              for (var i = 0; i < nonAlphanumeric.length; i++) {\n                const nonAlpha = nonAlphanumeric.charAt(i);\n                if (string.indexOf(nonAlpha) > -1) return false;\n              }\n            }\n\n            break;\n\n          case 'number':\n            for (var i = 0; i < string.length; i++) {\n              if ('0123456789'.indexOf(string.charAt(i)) === -1) if (i === 0) {\n                if ('-' !== string.charAt(0)) return false;\n              } else if ('.' !== string.charAt(i)) return false;\n            }\n\n            break;\n\n          case 'symbol':\n            if (string.length > 1) return false;\n            if ('{[:]},'.indexOf(string) === -1) return false;\n            break;\n\n          case 'colon':\n            if (string.length > 1) return false;\n            if (':' !== string) return false;\n            break;\n\n          default:\n            return true;\n            break;\n        }\n\n        return true;\n      }\n\n      for (var i = 0; i < buffer.tokens_proto.length; i++) {\n        let token = buffer.tokens_proto[i];\n\n        if (token.type.indexOf('proto') === -1) {\n          if (!validToken(token.string, token.type)) {\n            buffer.tokens_split = buffer.tokens_split.concat(quarkize(token.string, 'split'));\n          } else buffer.tokens_split.push(token);\n        } else buffer.tokens_split.push(token);\n      }\n\n      for (var i = 0; i < buffer.tokens_split.length; i++) {\n        let token = buffer.tokens_split[i];\n        let type = token.type,\n            string = token.string,\n            length = string.length,\n            fallback = [];\n\n        if (type.indexOf('-') > -1) {\n          type = type.slice(type.indexOf('-') + 1);\n          if (type !== 'string') fallback.push('string');\n          fallback.push('key');\n          fallback.push('error');\n        }\n\n        let tokul = {\n          string: string,\n          length: length,\n          type: type,\n          fallback: fallback\n        };\n        buffer.tokens_fallback.push(tokul);\n      }\n\n      function tokenFollowed() {\n        const last = buffer.tokens_normalize.length - 1;\n        if (last < 1) return false;\n\n        for (var i = last; i >= 0; i--) {\n          const previousToken = buffer.tokens_normalize[i];\n\n          switch (previousToken.type) {\n            case 'space':\n            case 'linebreak':\n              break;\n\n            default:\n              return previousToken;\n              break;\n          }\n        }\n\n        return false;\n      }\n\n      let buffer2 = {\n        brackets: [],\n        stringOpen: false,\n        isValue: false\n      };\n\n      for (var i = 0; i < buffer.tokens_fallback.length; i++) {\n        let token = buffer.tokens_fallback[i];\n        const type = token.type,\n              string = token.string;\n        let normalToken = {\n          type: type,\n          string: string\n        };\n\n        switch (type) {\n          case 'symbol':\n          case 'colon':\n            if (buffer2.stringOpen) {\n              if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n              break;\n            }\n\n            switch (string) {\n              case '[':\n              case '{':\n                buffer2.brackets.push(string);\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                break;\n\n              case ']':\n              case '}':\n                buffer2.brackets.pop();\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                break;\n\n              case ',':\n                if (tokenFollowed().type === 'colon') break;\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                break;\n\n              case ':':\n                normalToken.type = 'colon';\n                buffer2.isValue = true;\n                break;\n            }\n\n            break;\n\n          case 'delimiter':\n            if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n\n            if (!buffer2.stringOpen) {\n              buffer2.stringOpen = string;\n              break;\n            }\n\n            if (i > 0) {\n              const previousToken = buffer.tokens_fallback[i - 1],\n                    _string = previousToken.string,\n                    _type = previousToken.type,\n                    _char = _string.charAt(_string.length - 1);\n\n              if (_type === 'string' && _char === '\\\\') break;\n            }\n\n            if (buffer2.stringOpen === string) {\n              buffer2.stringOpen = false;\n              break;\n            }\n\n            break;\n\n          case 'primitive':\n          case 'string':\n            if (['false', 'true', 'null', 'undefined'].indexOf(string) > -1) {\n              const lastIndex = buffer.tokens_normalize.length - 1;\n\n              if (lastIndex >= 0) {\n                if (buffer.tokens_normalize[lastIndex].type !== 'string') {\n                  normalToken.type = 'primitive';\n                  break;\n                }\n\n                normalToken.type = 'string';\n                break;\n              }\n\n              normalToken.type = 'primitive';\n              break;\n            }\n\n            if (string === '\\n') if (!buffer2.stringOpen) {\n              normalToken.type = 'linebreak';\n              break;\n            }\n            if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n            break;\n\n          case 'space':\n            if (buffer2.stringOpen) if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n            break;\n\n          case 'number':\n            if (buffer2.stringOpen) if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n            break;\n\n          default:\n            break;\n        }\n\n        buffer.tokens_normalize.push(normalToken);\n      }\n\n      for (var i = 0; i < buffer.tokens_normalize.length; i++) {\n        const token = buffer.tokens_normalize[i];\n        let mergedToken = {\n          string: token.string,\n          type: token.type,\n          tokens: [i]\n        };\n        if (['symbol', 'colon'].indexOf(token.type) === -1) if (i + 1 < buffer.tokens_normalize.length) {\n          let count = 0;\n\n          for (var u = i + 1; u < buffer.tokens_normalize.length; u++) {\n            const nextToken = buffer.tokens_normalize[u];\n            if (token.type !== nextToken.type) break;\n            mergedToken.string += nextToken.string;\n            mergedToken.tokens.push(u);\n            count++;\n          }\n\n          i += count;\n        }\n        buffer.tokens_merge.push(mergedToken);\n      }\n\n      const quotes = '\\'\"',\n            alphanumeric = 'abcdefghijklmnopqrstuvwxyz' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '0123456789' + '_$';\n      var error = false,\n          line = buffer.tokens_merge.length > 0 ? 1 : 0;\n      buffer2 = {\n        brackets: [],\n        stringOpen: false,\n        isValue: false\n      };\n\n      function setError(tokenID, reason, offset = 0) {\n        error = {\n          token: tokenID,\n          line: line,\n          reason: reason\n        };\n        buffer.tokens_merge[tokenID + offset].type = 'error';\n      }\n\n      function followedBySymbol(tokenID, options) {\n        if (tokenID === undefined) console.error('tokenID argument must be an integer.');\n        if (options === undefined) console.error('options argument must be an array.');\n        if (tokenID === buffer.tokens_merge.length - 1) return false;\n\n        for (var i = tokenID + 1; i < buffer.tokens_merge.length; i++) {\n          const nextToken = buffer.tokens_merge[i];\n\n          switch (nextToken.type) {\n            case 'space':\n            case 'linebreak':\n              break;\n\n            case 'symbol':\n            case 'colon':\n              if (options.indexOf(nextToken.string) > -1) return i;else return false;\n              break;\n\n            default:\n              return false;\n              break;\n          }\n        }\n\n        return false;\n      }\n\n      function followsSymbol(tokenID, options) {\n        if (tokenID === undefined) console.error('tokenID argument must be an integer.');\n        if (options === undefined) console.error('options argument must be an array.');\n        if (tokenID === 0) return false;\n\n        for (var i = tokenID - 1; i >= 0; i--) {\n          const previousToken = buffer.tokens_merge[i];\n\n          switch (previousToken.type) {\n            case 'space':\n            case 'linebreak':\n              break;\n\n            case 'symbol':\n            case 'colon':\n              if (options.indexOf(previousToken.string) > -1) return true;\n              return false;\n              break;\n\n            default:\n              return false;\n              break;\n          }\n        }\n\n        return false;\n      }\n\n      function typeFollowed(tokenID) {\n        if (tokenID === undefined) console.error('tokenID argument must be an integer.');\n        if (tokenID === 0) return false;\n\n        for (var i = tokenID - 1; i >= 0; i--) {\n          const previousToken = buffer.tokens_merge[i];\n\n          switch (previousToken.type) {\n            case 'space':\n            case 'linebreak':\n              break;\n\n            default:\n              return previousToken.type;\n              break;\n          }\n        }\n\n        return false;\n      }\n\n      let bracketList = [];\n\n      for (var i = 0; i < buffer.tokens_merge.length; i++) {\n        if (error) break;\n        let token = buffer.tokens_merge[i],\n            string = token.string,\n            type = token.type,\n            found = false;\n\n        switch (type) {\n          case 'space':\n            break;\n\n          case 'linebreak':\n            line++;\n            break;\n\n          case 'symbol':\n            switch (string) {\n              case '{':\n              case '[':\n                found = followsSymbol(i, ['}', ']']);\n\n                if (found) {\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.prohibited, {\n                    firstToken: buffer.tokens_merge[found].string,\n                    secondToken: string\n                  }));\n                  break;\n                }\n\n                if (string === '[' && i > 0) if (!followsSymbol(i, [':', '[', ','])) {\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.permitted, {\n                    firstToken: \"[\",\n                    secondToken: [\":\", \"[\", \",\"]\n                  }));\n                  break;\n                }\n                if (string === '{') if (followsSymbol(i, ['{'])) {\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.double, {\n                    token: \"{\"\n                  }));\n                  break;\n                }\n                buffer2.brackets.push(string);\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                bracketList.push({\n                  i: i,\n                  line: line,\n                  string: string\n                });\n                break;\n\n              case '}':\n              case ']':\n                if (string === '}') if (buffer2.brackets[buffer2.brackets.length - 1] !== '{') {\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.brace.curly.missingOpen));\n                  break;\n                }\n                if (string === '}') if (followsSymbol(i, [','])) {\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.prohibited, {\n                    firstToken: \",\",\n                    secondToken: \"}\"\n                  }));\n                  break;\n                }\n                if (string === ']') if (buffer2.brackets[buffer2.brackets.length - 1] !== '[') {\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.brace.square.missingOpen));\n                  break;\n                }\n                if (string === ']') if (followsSymbol(i, [':'])) {\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.prohibited, {\n                    firstToken: \":\",\n                    secondToken: \"]\"\n                  }));\n                  break;\n                }\n                buffer2.brackets.pop();\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                bracketList.push({\n                  i: i,\n                  line: line,\n                  string: string\n                });\n                break;\n\n              case ',':\n                found = followsSymbol(i, ['{']);\n\n                if (found) {\n                  if (followedBySymbol(i, ['}'])) {\n                    setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.brace.curly.cannotWrap, {\n                      token: \",\"\n                    }));\n                    break;\n                  }\n\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.prohibited, {\n                    firstToken: \"{\",\n                    secondToken: \",\"\n                  }));\n                  break;\n                }\n\n                if (followedBySymbol(i, ['}', ',', ']'])) {\n                  setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.noTrailingOrLeadingComma));\n                  break;\n                }\n\n                found = typeFollowed(i);\n\n                switch (found) {\n                  case 'key':\n                  case 'colon':\n                    setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.termSequence.prohibited, {\n                      firstTerm: found === 'key' ? locale.types.key : locale.symbols.colon,\n                      secondTerm: locale.symbols.comma\n                    }));\n                    break;\n\n                  case 'symbol':\n                    if (followsSymbol(i, ['{'])) {\n                      setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.prohibited, {\n                        firstToken: \"{\",\n                        secondToken: \",\"\n                      }));\n                      break;\n                    }\n\n                    break;\n\n                  default:\n                    break;\n                }\n\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                break;\n\n              default:\n                break;\n            }\n\n            buffer.json += string;\n            break;\n\n          case 'colon':\n            found = followsSymbol(i, ['[']);\n\n            if (found && followedBySymbol(i, [']'])) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.brace.square.cannotWrap, {\n                token: \":\"\n              }));\n              break;\n            }\n\n            if (found) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.prohibited, {\n                firstToken: \"[\",\n                secondToken: \":\"\n              }));\n              break;\n            }\n\n            if (typeFollowed(i) !== 'key') {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.termSequence.permitted, {\n                firstTerm: locale.symbols.colon,\n                secondTerm: locale.types.key\n              }));\n              break;\n            }\n\n            if (followedBySymbol(i, ['}', ']'])) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.termSequence.permitted, {\n                firstTerm: locale.symbols.colon,\n                secondTerm: locale.types.value\n              }));\n              break;\n            }\n\n            buffer2.isValue = true;\n            buffer.json += string;\n            break;\n\n          case 'key':\n          case 'string':\n            let firstChar = string.charAt(0),\n                lastChar = string.charAt(string.length - 1),\n                quote_primary = quotes.indexOf(firstChar);\n            if (quotes.indexOf(firstChar) === -1) if (quotes.indexOf(lastChar) !== -1) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.string.missingOpen, {\n                quote: firstChar\n              }));\n              break;\n            }\n            if (quotes.indexOf(lastChar) === -1) if (quotes.indexOf(firstChar) !== -1) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.string.missingClose, {\n                quote: firstChar\n              }));\n              break;\n            }\n            if (quotes.indexOf(firstChar) > -1) if (firstChar !== lastChar) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.string.missingClose, {\n                quote: firstChar\n              }));\n              break;\n            }\n            if ('string' === type) if (quotes.indexOf(firstChar) === -1 && quotes.indexOf(lastChar) === -1) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.string.mustBeWrappedByQuotes));\n              break;\n            }\n            if ('key' === type) if (followedBySymbol(i, ['}', ']'])) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.termSequence.permitted, {\n                firstTerm: locale.types.key,\n                secondTerm: locale.symbols.colon\n              }));\n            }\n            if (quotes.indexOf(firstChar) === -1 && quotes.indexOf(lastChar) === -1) for (var h = 0; h < string.length; h++) {\n              if (error) break;\n              const c = string.charAt(h);\n\n              if (alphanumeric.indexOf(c) === -1) {\n                setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.string.nonAlphanumeric, {\n                  token: c\n                }));\n                break;\n              }\n            }\n            if (firstChar === \"'\") string = '\"' + string.slice(1, -1) + '\"';else if (firstChar !== '\"') string = '\"' + string + '\"';\n            if ('key' === type) if ('key' === typeFollowed(i)) {\n              if (i > 0) if (!isNaN(buffer.tokens_merge[i - 1])) {\n                buffer.tokens_merge[i - 1] += buffer.tokens_merge[i];\n                setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.key.numberAndLetterMissingQuotes));\n                break;\n              }\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.key.spaceMissingQuotes));\n              break;\n            }\n            if ('key' === type) if (!followsSymbol(i, ['{', ','])) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.permitted, {\n                firstToken: type,\n                secondToken: [\"{\", \",\"]\n              }));\n              break;\n            }\n            if ('string' === type) if (!followsSymbol(i, ['[', ':', ','])) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.permitted, {\n                firstToken: type,\n                secondToken: [\"[\", \":\", \",\"]\n              }));\n              break;\n            }\n            if ('key' === type) if (buffer2.isValue) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.string.unexpectedKey));\n              break;\n            }\n            if ('string' === type) if (!buffer2.isValue) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.key.unexpectedString));\n              break;\n            }\n            buffer.json += string;\n            break;\n\n          case 'number':\n          case 'primitive':\n            if (followsSymbol(i, ['{'])) {\n              buffer.tokens_merge[i].type = 'key';\n              type = buffer.tokens_merge[i].type;\n              string = '\"' + string + '\"';\n            } else if (typeFollowed(i) === 'key') {\n              buffer.tokens_merge[i].type = 'key';\n              type = buffer.tokens_merge[i].type;\n            } else if (!followsSymbol(i, ['[', ':', ','])) {\n              setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.tokenSequence.permitted, {\n                firstToken: type,\n                secondToken: [\"[\", \":\", \",\"]\n              }));\n              break;\n            }\n\n            if (type !== 'key') if (!buffer2.isValue) {\n              buffer.tokens_merge[i].type = 'key';\n              type = buffer.tokens_merge[i].type;\n              string = '\"' + string + '\"';\n            }\n            if (type === 'primitive') if (string === 'undefined') setError(i, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.useInstead, {\n              badToken: \"undefined\",\n              goodToken: \"null\"\n            }));\n            buffer.json += string;\n            break;\n        }\n      }\n\n      let noEscapedSingleQuote = '';\n\n      for (var i = 0; i < buffer.json.length; i++) {\n        let current = buffer.json.charAt(i),\n            next = '';\n\n        if (i + 1 < buffer.json.length) {\n          next = buffer.json.charAt(i + 1);\n\n          if (current === '\\\\' && next === \"'\") {\n            noEscapedSingleQuote += next;\n            i++;\n            continue;\n          }\n        }\n\n        noEscapedSingleQuote += current;\n      }\n\n      buffer.json = noEscapedSingleQuote;\n\n      if (!error) {\n        const maxIterations = Math.ceil(bracketList.length / 2);\n        let round = 0,\n            delta = false;\n\n        function removePair(index) {\n          bracketList.splice(index + 1, 1);\n          bracketList.splice(index, 1);\n          if (!delta) delta = true;\n        }\n\n        while (bracketList.length > 0) {\n          delta = false;\n\n          for (var tokenCount = 0; tokenCount < bracketList.length - 1; tokenCount++) {\n            const pair = bracketList[tokenCount].string + bracketList[tokenCount + 1].string;\n            if (['[]', '{}'].indexOf(pair) > -1) removePair(tokenCount);\n          }\n\n          round++;\n          if (!delta) break;\n          if (round >= maxIterations) break;\n        }\n\n        if (bracketList.length > 0) {\n          const _tokenString = bracketList[0].string,\n                _tokenPosition = bracketList[0].i,\n                _closingBracketType = _tokenString === '[' ? ']' : '}';\n\n          line = bracketList[0].line;\n          setError(_tokenPosition, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.brace[_closingBracketType === ']' ? 'square' : 'curly'].missingClose));\n        }\n      }\n\n      if (!error) if ([undefined, ''].indexOf(buffer.json) === -1) try {\n        buffer.jsObject = JSON.parse(buffer.json);\n      } catch (err) {\n        const errorMessage = err.message,\n              subsMark = errorMessage.indexOf('position');\n        if (subsMark === -1) throw new Error('Error parsing failed');\n        const errPositionStr = errorMessage.substring(subsMark + 9, errorMessage.length),\n              errPosition = parseInt(errPositionStr);\n        let charTotal = 0,\n            tokenIndex = 0,\n            token = false,\n            _line = 1,\n            exitWhile = false;\n\n        while (charTotal < errPosition && !exitWhile) {\n          token = buffer.tokens_merge[tokenIndex];\n          if ('linebreak' === token.type) _line++;\n          if (['space', 'linebreak'].indexOf(token.type) === -1) charTotal += token.string.length;\n          if (charTotal >= errPosition) break;\n          tokenIndex++;\n          if (!buffer.tokens_merge[tokenIndex + 1]) exitWhile = true;\n        }\n\n        line = _line;\n        let backslashCount = 0;\n\n        for (let i = 0; i < token.string.length; i++) {\n          const char = token.string.charAt(i);\n          if (char === '\\\\') backslashCount = backslashCount > 0 ? backslashCount + 1 : 1;else {\n            if (backslashCount % 2 !== 0 || backslashCount === 0) if ('\\'\"bfnrt'.indexOf(char) === -1) {\n              setError(tokenIndex, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.unexpected, {\n                token: '\\\\'\n              }));\n            }\n            backslashCount = 0;\n          }\n        }\n\n        if (!error) setError(tokenIndex, Object(_locale__WEBPACK_IMPORTED_MODULE_5__[\"format\"])(locale.invalidToken.unexpected, {\n          token: token.string\n        }));\n      }\n      let _line = 1,\n          _depth = 0;\n\n      function newIndent() {\n        var space = [];\n\n        for (var i = 0; i < _depth * 2; i++) space.push('&nbsp;');\n\n        return space.join('');\n      }\n\n      function newLineBreak(byPass = false) {\n        _line++;\n\n        if (_depth > 0 || byPass) {\n          return '<br>';\n        }\n\n        return '';\n      }\n\n      function newLineBreakAndIndent(byPass = false) {\n        return newLineBreak(byPass) + newIndent();\n      }\n\n      ;\n      if (!error) for (var i = 0; i < buffer.tokens_merge.length; i++) {\n        const token = buffer.tokens_merge[i],\n              string = token.string,\n              type = token.type;\n\n        switch (type) {\n          case 'space':\n          case 'linebreak':\n            break;\n\n          case 'string':\n          case 'number':\n          case 'primitive':\n          case 'error':\n            buffer.markup += (followsSymbol(i, [',', '[']) ? newLineBreakAndIndent() : '') + newSpan(i, token, _depth);\n            break;\n\n          case 'key':\n            buffer.markup += newLineBreakAndIndent() + newSpan(i, token, _depth);\n            break;\n\n          case 'colon':\n            buffer.markup += newSpan(i, token, _depth) + '&nbsp;';\n            break;\n\n          case 'symbol':\n            switch (string) {\n              case '[':\n              case '{':\n                buffer.markup += (!followsSymbol(i, [':']) ? newLineBreakAndIndent() : '') + newSpan(i, token, _depth);\n                _depth++;\n                break;\n\n              case ']':\n              case '}':\n                _depth--;\n\n                const islastToken = i === buffer.tokens_merge.length - 1,\n                      _adjustment = i > 0 ? ['[', '{'].indexOf(buffer.tokens_merge[i - 1].string) > -1 ? '' : newLineBreakAndIndent(islastToken) : '';\n\n                buffer.markup += _adjustment + newSpan(i, token, _depth);\n                break;\n\n              case ',':\n                buffer.markup += newSpan(i, token, _depth);\n                break;\n            }\n\n            break;\n        }\n      }\n\n      if (error) {\n        let _line_fallback = 1;\n\n        function countCarrigeReturn(string) {\n          let count = 0;\n\n          for (var i = 0; i < string.length; i++) {\n            if (['\\n', '\\r'].indexOf(string[i]) > -1) count++;\n          }\n\n          return count;\n        }\n\n        _line = 1;\n\n        for (var i = 0; i < buffer.tokens_merge.length; i++) {\n          const token = buffer.tokens_merge[i],\n                type = token.type,\n                string = token.string;\n          if (type === 'linebreak') _line++;\n          buffer.markup += newSpan(i, token, _depth);\n          _line_fallback += countCarrigeReturn(string);\n        }\n\n        _line++;\n        _line_fallback++;\n        if (_line < _line_fallback) _line = _line_fallback;\n      }\n\n      for (var i = 0; i < buffer.tokens_merge.length; i++) {\n        let token = buffer.tokens_merge[i];\n        buffer.indented += token.string;\n        if (['space', 'linebreak'].indexOf(token.type) === -1) buffer.tokens_plainText += token.string;\n      }\n\n      if (error) {\n        function isFunction(functionToCheck) {\n          return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n        }\n\n        if ('modifyErrorText' in this.props) if (isFunction(this.props.modifyErrorText)) error.reason = this.props.modifyErrorText(error.reason);\n      }\n\n      return {\n        tokens: buffer.tokens_merge,\n        noSpaces: buffer.tokens_plainText,\n        indented: buffer.indented,\n        json: buffer.json,\n        jsObject: buffer.jsObject,\n        markup: buffer.markup,\n        lines: _line,\n        error: error\n      };\n    }\n\n    ;\n    /**\r\n     *     JS OBJECTS || PLACEHOLDER\r\n     */\n\n    if (!('nodeType' in something)) {\n      let buffer = {\n        inputText: JSON.stringify(something),\n        position: 0,\n        currentChar: '',\n        tokenPrimary: '',\n        tokenSecondary: '',\n        brackets: [],\n        isValue: false,\n        stringOpen: false,\n        stringStart: 0,\n        tokens: []\n      };\n\n      function escape_character() {\n        if (buffer.currentChar !== '\\\\') return false;\n        buffer.inputText = deleteCharAt(buffer.inputText, buffer.position);\n        return true;\n      }\n\n      function deleteCharAt(string, position) {\n        return string.slice(0, position) + string.slice(position + 1);\n      }\n\n      function determine_string() {\n        if ('\\'\"'.indexOf(buffer.currentChar) === -1) return false;\n\n        if (!buffer.stringOpen) {\n          add_tokenSecondary();\n          buffer.stringStart = buffer.position;\n          buffer.stringOpen = buffer.currentChar;\n          return true;\n        }\n\n        if (buffer.stringOpen === buffer.currentChar) {\n          add_tokenSecondary();\n          const stringToken = buffer.inputText.substring(buffer.stringStart, buffer.position + 1);\n          add_tokenPrimary(stringToken);\n          buffer.stringOpen = false;\n          return true;\n        }\n\n        return false;\n      }\n\n      function determine_value() {\n        if (':,{}[]'.indexOf(buffer.currentChar) === -1) return false;\n        if (buffer.stringOpen) return false;\n        add_tokenSecondary();\n        add_tokenPrimary(buffer.currentChar);\n\n        switch (buffer.currentChar) {\n          case ':':\n            buffer.isValue = true;\n            return true;\n            break;\n\n          case '{':\n          case '[':\n            buffer.brackets.push(buffer.currentChar);\n            break;\n\n          case '}':\n          case ']':\n            buffer.brackets.pop();\n            break;\n        }\n\n        if (buffer.currentChar !== ':') buffer.isValue = buffer.brackets[buffer.brackets.length - 1] === '[';\n        return true;\n      }\n\n      function add_tokenSecondary() {\n        if (buffer.tokenSecondary.length === 0) return false;\n        buffer.tokens.push(buffer.tokenSecondary);\n        buffer.tokenSecondary = '';\n        return true;\n      }\n\n      function add_tokenPrimary(value) {\n        if (value.length === 0) return false;\n        buffer.tokens.push(value);\n        return true;\n      }\n\n      for (var i = 0; i < buffer.inputText.length; i++) {\n        buffer.position = i;\n        buffer.currentChar = buffer.inputText.charAt(buffer.position);\n        const a = determine_value(),\n              b = determine_string(),\n              c = escape_character();\n        if (!a && !b && !c) if (!buffer.stringOpen) buffer.tokenSecondary += buffer.currentChar;\n      }\n\n      let buffer2 = {\n        brackets: [],\n        isValue: false,\n        tokens: []\n      };\n      buffer2.tokens = buffer.tokens.map(token => {\n        let type = '',\n            string = '',\n            value = '';\n\n        switch (token) {\n          case ',':\n            type = 'symbol';\n            string = token;\n            value = token;\n            buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n            break;\n\n          case ':':\n            type = 'symbol';\n            string = token;\n            value = token;\n            buffer2.isValue = true;\n            break;\n\n          case '{':\n          case '[':\n            type = 'symbol';\n            string = token;\n            value = token;\n            buffer2.brackets.push(token);\n            buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n            break;\n\n          case '}':\n          case ']':\n            type = 'symbol';\n            string = token;\n            value = token;\n            buffer2.brackets.pop();\n            buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n            break;\n\n          case 'undefined':\n            type = 'primitive';\n            string = token;\n            value = undefined;\n            break;\n\n          case 'null':\n            type = 'primitive';\n            string = token;\n            value = null;\n            break;\n\n          case 'false':\n            type = 'primitive';\n            string = token;\n            value = false;\n            break;\n\n          case 'true':\n            type = 'primitive';\n            string = token;\n            value = true;\n            break;\n\n          default:\n            const C = token.charAt(0);\n\n            function stripQuotesFromKey(text) {\n              if (text.length === 0) return text;\n              if (['\"\"', \"''\"].indexOf(text) > -1) return \"''\";\n              let wrappedInQuotes = false;\n\n              for (var i = 0; i < 2; i++) {\n                if ([text.charAt(0), text.charAt(text.length - 1)].indexOf(['\"', \"'\"][i]) > -1) {\n                  wrappedInQuotes = true;\n                  break;\n                }\n              }\n\n              if (wrappedInQuotes && text.length >= 2) text = text.slice(1, -1);\n\n              const nonAlphaNumeric = text.replace(/\\w/g, ''),\n                    alphaNumeric = text.replace(/\\W+/g, ''),\n                    mayRemoveQuotes = ((nonAlphaNumeric, text) => {\n                let numberAndLetter = false;\n\n                for (var i = 0; i < text.length; i++) {\n                  if (i === 0) if (isNaN(text.charAt(i))) break;\n\n                  if (isNaN(text.charAt(i))) {\n                    numberAndLetter = true;\n                    break;\n                  }\n                }\n\n                return !(nonAlphaNumeric.length > 0 || numberAndLetter);\n              })(nonAlphaNumeric, text),\n                    hasQuotes = (string => {\n                for (var i = 0; i < string.length; i++) {\n                  if ([\"'\", '\"'].indexOf(string.charAt(i)) > -1) return true;\n                }\n\n                return false;\n              })(nonAlphaNumeric);\n\n              if (hasQuotes) {\n                let newText = '';\n                const charList = text.split('');\n\n                for (var ii = 0; ii < charList.length; ii++) {\n                  let char = charList[ii];\n                  if ([\"'\", '\"'].indexOf(char) > -1) char = '\\\\' + char;\n                  newText += char;\n                }\n\n                text = newText;\n              }\n\n              if (!mayRemoveQuotes) return \"'\" + text + \"'\";else return text;\n            }\n\n            if ('\\'\"'.indexOf(C) > -1) {\n              if (buffer2.isValue) type = 'string';else type = 'key';\n              if (type === 'key') string = stripQuotesFromKey(token);\n\n              if (type === 'string') {\n                string = '';\n                const charList2 = token.slice(1, -1).split('');\n\n                for (var ii = 0; ii < charList2.length; ii++) {\n                  let char = charList2[ii];\n                  if ('\\'\\\"'.indexOf(char) > -1) char = '\\\\' + char;\n                  string += char;\n                }\n\n                string = \"'\" + string + \"'\";\n              }\n\n              value = string;\n              break;\n            }\n\n            if (!isNaN(token)) {\n              type = 'number';\n              string = token;\n              value = Number(token);\n              break;\n            }\n\n            if (token.length > 0) if (!buffer2.isValue) {\n              type = 'key';\n              string = token;\n              if (string.indexOf(' ') > -1) string = \"'\" + string + \"'\";\n              value = string;\n              break;\n            }\n        }\n\n        return {\n          type: type,\n          string: string,\n          value: value,\n          depth: buffer2.brackets.length\n        };\n      });\n      let clean = '';\n\n      for (var i = 0; i < buffer2.tokens.length; i++) {\n        let token = buffer2.tokens[i];\n        clean += token.string;\n      }\n\n      function indent(number) {\n        var space = [];\n\n        for (var i = 0; i < number * 2; i++) space.push(' ');\n\n        return (number > 0 ? '\\n' : '') + space.join('');\n      }\n\n      ;\n      let indentation = '';\n\n      for (var i = 0; i < buffer2.tokens.length; i++) {\n        let token = buffer2.tokens[i];\n\n        switch (token.string) {\n          case '[':\n          case '{':\n            const nextToken = i < buffer2.tokens.length - 1 - 1 ? buffer2.tokens[i + 1] : '';\n            if ('}]'.indexOf(nextToken.string) === -1) indentation += token.string + indent(token.depth);else indentation += token.string;\n            break;\n\n          case ']':\n          case '}':\n            const prevToken = i > 0 ? buffer2.tokens[i - 1] : '';\n            if ('[{'.indexOf(prevToken.string) === -1) indentation += indent(token.depth) + token.string;else indentation += token.string;\n            break;\n\n          case ':':\n            indentation += token.string + ' ';\n            break;\n\n          case ',':\n            indentation += token.string + indent(token.depth);\n            break;\n\n          default:\n            indentation += token.string;\n            break;\n        }\n      }\n\n      let lines = 1;\n\n      function indentII(number) {\n        var space = [];\n        if (number > 0) lines++;\n\n        for (var i = 0; i < number * 2; i++) space.push('&nbsp;');\n\n        return (number > 0 ? '<br>' : '') + space.join('');\n      }\n\n      ;\n      let markup = '';\n      const lastIndex = buffer2.tokens.length - 1;\n\n      for (var i = 0; i < buffer2.tokens.length; i++) {\n        let token = buffer2.tokens[i];\n        let span = newSpan(i, token, token.depth);\n\n        switch (token.string) {\n          case '{':\n          case '[':\n            const nextToken = i < buffer2.tokens.length - 1 - 1 ? buffer2.tokens[i + 1] : '';\n            if ('}]'.indexOf(nextToken.string) === -1) markup += span + indentII(token.depth);else markup += span;\n            break;\n\n          case '}':\n          case ']':\n            const prevToken = i > 0 ? buffer2.tokens[i - 1] : '';\n            if ('[{'.indexOf(prevToken.string) === -1) markup += indentII(token.depth) + (lastIndex === i ? '<br>' : '') + span;else markup += span;\n            break;\n\n          case ':':\n            markup += span + ' ';\n            break;\n\n          case ',':\n            markup += span + indentII(token.depth);\n            break;\n\n          default:\n            markup += span;\n            break;\n        }\n      }\n\n      lines += 2;\n      return {\n        tokens: buffer2.tokens,\n        noSpaces: clean,\n        indented: indentation,\n        json: JSON.stringify(something),\n        jsObject: something,\n        markup: markup,\n        lines: lines\n      };\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (JSONInput);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL2luZGV4LmpzPzc3YjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIHJlYWN0LWpzb24tZWRpdG9yLWFqcm0gdjIuNS45XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWRcIjtcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdGhlbWVzIGZyb20gJy4vdGhlbWVzJztcbmltcG9ydCB7IGlkZW50aWNhbCwgZ2V0VHlwZSB9IGZyb20gJy4vbWl0c3VrZXRhJztcbmltcG9ydCBlcnIgZnJvbSAnLi9lcnInO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnLi9sb2NhbGUnO1xuaW1wb3J0IGRlZmF1bHRMb2NhbGUgZnJvbSAnLi9sb2NhbGUvZW4nO1xuXG5jbGFzcyBKU09OSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnVwZGF0ZUludGVybmFsUHJvcHMgPSB0aGlzLnVwZGF0ZUludGVybmFsUHJvcHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNyZWF0ZU1hcmt1cCA9IHRoaXMuY3JlYXRlTWFya3VwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkJsdXIgPSB0aGlzLm9uQmx1ci5iaW5kKHRoaXMpO1xuICAgIHRoaXMudXBkYXRlID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldEN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXRDdXJzb3JQb3NpdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0Q3Vyc29yUG9zaXRpb24gPSB0aGlzLnNldEN1cnNvclBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zY2hlZHVsZWRVcGRhdGUgPSB0aGlzLnNjaGVkdWxlZFVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0VXBkYXRlVGltZSA9IHRoaXMuc2V0VXBkYXRlVGltZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyTGFiZWxzID0gdGhpcy5yZW5kZXJMYWJlbHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLm5ld1NwYW4gPSB0aGlzLm5ld1NwYW4uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbmRlckVycm9yTWVzc2FnZSA9IHRoaXMucmVuZGVyRXJyb3JNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblNjcm9sbCA9IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNob3dQbGFjZWhvbGRlciA9IHRoaXMuc2hvd1BsYWNlaG9sZGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy50b2tlbml6ZSA9IHRoaXMudG9rZW5pemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uS2V5UHJlc3MgPSB0aGlzLm9uS2V5UHJlc3MuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uS2V5RG93biA9IHRoaXMub25LZXlEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblBhc3RlID0gdGhpcy5vblBhc3RlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdG9wRXZlbnQgPSB0aGlzLnN0b3BFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmQ29udGVudCA9IG51bGw7XG4gICAgdGhpcy5yZWZMYWJlbHMgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlSW50ZXJuYWxQcm9wcygpO1xuICAgIHRoaXMucmVuZGVyQ291bnQgPSAxO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBwcmV2UGxhY2Vob2xkZXI6ICcnLFxuICAgICAgbWFya3VwVGV4dDogJycsXG4gICAgICBwbGFpblRleHQ6ICcnLFxuICAgICAganNvbjogJycsXG4gICAgICBqc09iamVjdDogdW5kZWZpbmVkLFxuICAgICAgbGluZXM6IGZhbHNlLFxuICAgICAgZXJyb3I6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5wcm9wcy5sb2NhbGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltyZWFjdC1qc29uLWVkaXRvci1hanJtIC0gRGVwcmVjYXRpb24gV2FybmluZ10gWW91IGRpZCBub3QgcHJvdmlkZSBhICdsb2NhbGUnIHByb3AgZm9yIHlvdXIgSlNPTiBpbnB1dCAtIFRoaXMgd2lsbCBiZSByZXF1aXJlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBFbmdsaXNoIGhhcyBiZWVuIHNldCBhcyBhIGRlZmF1bHQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUludGVybmFsUHJvcHMoKSB7XG4gICAgbGV0IGNvbG9ycyA9IHt9LFxuICAgICAgICBzdHlsZSA9IHt9LFxuICAgICAgICB0aGVtZSA9IHRoZW1lcy5kYXJrX3ZzY29kZV90cmlidXRlO1xuICAgIGlmICgndGhlbWUnIGluIHRoaXMucHJvcHMpIGlmICh0eXBlb2YgdGhpcy5wcm9wcy50aGVtZSA9PT0gJ3N0cmluZycpIGlmICh0aGlzLnByb3BzLnRoZW1lIGluIHRoZW1lcykgdGhlbWUgPSB0aGVtZXNbdGhpcy5wcm9wcy50aGVtZV07XG4gICAgY29sb3JzID0gdGhlbWU7XG4gICAgaWYgKCdjb2xvcnMnIGluIHRoaXMucHJvcHMpIGNvbG9ycyA9IHtcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0JyBpbiB0aGlzLnByb3BzLmNvbG9ycyA/IHRoaXMucHJvcHMuY29sb3JzLmRlZmF1bHQgOiBjb2xvcnMuZGVmYXVsdCxcbiAgICAgIHN0cmluZzogJ3N0cmluZycgaW4gdGhpcy5wcm9wcy5jb2xvcnMgPyB0aGlzLnByb3BzLmNvbG9ycy5zdHJpbmcgOiBjb2xvcnMuc3RyaW5nLFxuICAgICAgbnVtYmVyOiAnbnVtYmVyJyBpbiB0aGlzLnByb3BzLmNvbG9ycyA/IHRoaXMucHJvcHMuY29sb3JzLm51bWJlciA6IGNvbG9ycy5udW1iZXIsXG4gICAgICBjb2xvbjogJ2NvbG9uJyBpbiB0aGlzLnByb3BzLmNvbG9ycyA/IHRoaXMucHJvcHMuY29sb3JzLmNvbG9uIDogY29sb3JzLmNvbG9uLFxuICAgICAga2V5czogJ2tleXMnIGluIHRoaXMucHJvcHMuY29sb3JzID8gdGhpcy5wcm9wcy5jb2xvcnMua2V5cyA6IGNvbG9ycy5rZXlzLFxuICAgICAga2V5c193aGl0ZVNwYWNlOiAna2V5c193aGl0ZVNwYWNlJyBpbiB0aGlzLnByb3BzLmNvbG9ycyA/IHRoaXMucHJvcHMuY29sb3JzLmtleXNfd2hpdGVTcGFjZSA6IGNvbG9ycy5rZXlzX3doaXRlU3BhY2UsXG4gICAgICBwcmltaXRpdmU6ICdwcmltaXRpdmUnIGluIHRoaXMucHJvcHMuY29sb3JzID8gdGhpcy5wcm9wcy5jb2xvcnMucHJpbWl0aXZlIDogY29sb3JzLnByaW1pdGl2ZSxcbiAgICAgIGVycm9yOiAnZXJyb3InIGluIHRoaXMucHJvcHMuY29sb3JzID8gdGhpcy5wcm9wcy5jb2xvcnMuZXJyb3IgOiBjb2xvcnMuZXJyb3IsXG4gICAgICBiYWNrZ3JvdW5kOiAnYmFja2dyb3VuZCcgaW4gdGhpcy5wcm9wcy5jb2xvcnMgPyB0aGlzLnByb3BzLmNvbG9ycy5iYWNrZ3JvdW5kIDogY29sb3JzLmJhY2tncm91bmQsXG4gICAgICBiYWNrZ3JvdW5kX3dhcm5pbmc6ICdiYWNrZ3JvdW5kX3dhcm5pbmcnIGluIHRoaXMucHJvcHMuY29sb3JzID8gdGhpcy5wcm9wcy5jb2xvcnMuYmFja2dyb3VuZF93YXJuaW5nIDogY29sb3JzLmJhY2tncm91bmRfd2FybmluZ1xuICAgIH07XG4gICAgdGhpcy5jb2xvcnMgPSBjb2xvcnM7XG4gICAgaWYgKCdzdHlsZScgaW4gdGhpcy5wcm9wcykgc3R5bGUgPSB7XG4gICAgICBvdXRlckJveDogJ291dGVyQm94JyBpbiB0aGlzLnByb3BzLnN0eWxlID8gdGhpcy5wcm9wcy5zdHlsZS5vdXRlckJveCA6IHt9LFxuICAgICAgY29udGFpbmVyOiAnY29udGFpbmVyJyBpbiB0aGlzLnByb3BzLnN0eWxlID8gdGhpcy5wcm9wcy5zdHlsZS5jb250YWluZXIgOiB7fSxcbiAgICAgIHdhcm5pbmdCb3g6ICd3YXJuaW5nQm94JyBpbiB0aGlzLnByb3BzLnN0eWxlID8gdGhpcy5wcm9wcy5zdHlsZS53YXJuaW5nQm94IDoge30sXG4gICAgICBlcnJvck1lc3NhZ2U6ICdlcnJvck1lc3NhZ2UnIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmVycm9yTWVzc2FnZSA6IHt9LFxuICAgICAgYm9keTogJ2JvZHknIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmJvZHkgOiB7fSxcbiAgICAgIGxhYmVsQ29sdW1uOiAnbGFiZWxDb2x1bW4nIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmxhYmVsQ29sdW1uIDoge30sXG4gICAgICBsYWJlbHM6ICdsYWJlbHMnIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmxhYmVscyA6IHt9LFxuICAgICAgY29udGVudEJveDogJ2NvbnRlbnRCb3gnIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmNvbnRlbnRCb3ggOiB7fVxuICAgIH07ZWxzZSBzdHlsZSA9IHtcbiAgICAgIG91dGVyQm94OiB7fSxcbiAgICAgIGNvbnRhaW5lcjoge30sXG4gICAgICB3YXJuaW5nQm94OiB7fSxcbiAgICAgIGVycm9yTWVzc2FnZToge30sXG4gICAgICBib2R5OiB7fSxcbiAgICAgIGxhYmVsQ29sdW1uOiB7fSxcbiAgICAgIGxhYmVsczoge30sXG4gICAgICBjb250ZW50Qm94OiB7fVxuICAgIH07XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuY29uZmlybUdvb2QgPSAnY29uZmlybUdvb2QnIGluIHRoaXMucHJvcHMgPyB0aGlzLnByb3BzLmNvbmZpcm1Hb29kIDogdHJ1ZTtcbiAgICBjb25zdCB0b3RhbEhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0IHx8ICc2MTBweCcsXG4gICAgICAgICAgdG90YWxXaWR0aCA9IHRoaXMucHJvcHMud2lkdGggfHwgJzQ3OXB4JztcbiAgICB0aGlzLnRvdGFsSGVpZ2h0ID0gdG90YWxIZWlnaHQ7XG4gICAgdGhpcy50b3RhbFdpZHRoID0gdG90YWxXaWR0aDtcblxuICAgIGlmICghKCdvbktleVByZXNzVXBkYXRlJyBpbiB0aGlzLnByb3BzKSB8fCB0aGlzLnByb3BzLm9uS2V5UHJlc3NVcGRhdGUpIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuc2NoZWR1bGVkVXBkYXRlLCAxMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLndhaXRBZnRlcktleVByZXNzID0gJ3dhaXRBZnRlcktleVByZXNzJyBpbiB0aGlzLnByb3BzID8gdGhpcy5wcm9wcy53YWl0QWZ0ZXJLZXlQcmVzcyA6IDEwMDA7XG4gICAgdGhpcy5yZXNldENvbmZpZ3VyYXRpb24gPSAncmVzZXQnIGluIHRoaXMucHJvcHMgPyB0aGlzLnByb3BzLnJlc2V0IDogZmFsc2U7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnByb3BzLmlkLFxuICAgICAgICAgIG1hcmt1cFRleHQgPSB0aGlzLnN0YXRlLm1hcmt1cFRleHQsXG4gICAgICAgICAgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICAgIGNvbG9ycyA9IHRoaXMuY29sb3JzLFxuICAgICAgICAgIHN0eWxlID0gdGhpcy5zdHlsZSxcbiAgICAgICAgICBjb25maXJtR29vZCA9IHRoaXMuY29uZmlybUdvb2QsXG4gICAgICAgICAgdG90YWxIZWlnaHQgPSB0aGlzLnRvdGFsSGVpZ2h0LFxuICAgICAgICAgIHRvdGFsV2lkdGggPSB0aGlzLnRvdGFsV2lkdGgsXG4gICAgICAgICAgaGFzRXJyb3IgPSBlcnJvciA/ICd0b2tlbicgaW4gZXJyb3IgOiBmYWxzZTtcbiAgICB0aGlzLnJlbmRlckNvdW50Kys7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgbmFtZTogXCJvdXRlci1ib3hcIixcbiAgICAgIGlkOiBpZCAmJiBpZCArICctb3V0ZXItYm94JyxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdub25lJyxcbiAgICAgICAgaGVpZ2h0OiB0b3RhbEhlaWdodCxcbiAgICAgICAgd2lkdGg6IHRvdGFsV2lkdGgsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9LCBzdHlsZS5vdXRlckJveClcbiAgICB9LCBjb25maXJtR29vZCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgb3BhY2l0eTogaGFzRXJyb3IgPyAwIDogMSxcbiAgICAgICAgaGVpZ2h0OiAnMzBweCcsXG4gICAgICAgIHdpZHRoOiAnMzBweCcsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTI1JSwyNSUpJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246ICcwLjJzJyxcbiAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAnY3ViaWMtYmV6aWVyKDAsIDEsIDAuNSwgMSknXG4gICAgICB9XG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICBoZWlnaHQ6IFwiMzBweFwiLFxuICAgICAgd2lkdGg6IFwiMzBweFwiLFxuICAgICAgdmlld0JveDogXCIwIDAgMTAwIDEwMFwiXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZmlsbDogXCJncmVlblwiLFxuICAgICAgb3BhY2l0eTogXCIwLjg1XCIsXG4gICAgICBkOiBcIk0zOS4zNjMsNzlMMTYsNTUuNDlsMTEuMzQ3LTExLjQxOUwzOS42OTQsNTYuNDlMNzIuOTgzLDIzTDg0LDM0LjA4NUwzOS4zNjMsNzl6XCJcbiAgICB9KSkpIDogdm9pZCAwLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIG5hbWU6IFwiY29udGFpbmVyXCIsXG4gICAgICBpZDogaWQgJiYgaWQgKyAnLWNvbnRhaW5lcicsXG4gICAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIGhlaWdodDogdG90YWxIZWlnaHQsXG4gICAgICAgIHdpZHRoOiB0b3RhbFdpZHRoLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdSb2JvdG8sIHNhbnMtc2VyaWYnXG4gICAgICB9LCBzdHlsZS5jb250YWluZXIpLFxuICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBuYW1lOiBcIndhcm5pbmctYm94XCIsXG4gICAgICBpZDogaWQgJiYgaWQgKyAnLXdhcm5pbmctYm94JyxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBoZWlnaHQ6IGhhc0Vycm9yID8gJzYwcHgnIDogJzBweCcsXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMuYmFja2dyb3VuZF93YXJuaW5nLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246ICcwLjJzJyxcbiAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAnY3ViaWMtYmV6aWVyKDAsIDEsIDAuNSwgMSknXG4gICAgICB9LCBzdHlsZS53YXJuaW5nQm94KSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGlja1xuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBoZWlnaHQ6ICc2MHB4JyxcbiAgICAgICAgd2lkdGg6ICc2MHB4JyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9LFxuICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBoZWlnaHQ6ICc2MHB4JyxcbiAgICAgICAgd2lkdGg6ICc2MHB4JyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9LFxuICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICBoZWlnaHQ6IFwiMjVweFwiLFxuICAgICAgd2lkdGg6IFwiMjVweFwiLFxuICAgICAgdmlld0JveDogXCIwIDAgMTAwIDEwMFwiXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZmlsbDogXCJyZWRcIixcbiAgICAgIGQ6IFwiTTczLjksNS43NWMwLjQ2Ny0wLjQ2NywxLjA2Ny0wLjcsMS44LTAuN2MwLjcsMCwxLjI4MywwLjIzMywxLjc1LDAuN2wxNi44LDE2LjggIGMwLjQ2NywwLjUsMC43LDEuMDg0LDAuNywxLjc1YzAsMC43MzMtMC4yMzMsMS4zMzQtMC43LDEuODAxTDcwLjM1LDUwbDIzLjksMjMuOTVjMC41LDAuNDY3LDAuNzUsMS4wNjYsMC43NSwxLjggIGMwLDAuNjY3LTAuMjUsMS4yNS0wLjc1LDEuNzVsLTE2LjgsMTYuNzVjLTAuNTM0LDAuNDY3LTEuMTE3LDAuNy0xLjc1LDAuN3MtMS4yMzMtMC4yMzMtMS44LTAuN0w1MCw3MC4zNTFMMjYuMSw5NC4yNSAgYy0wLjU2NywwLjQ2Ny0xLjE2NywwLjctMS44LDAuN2MtMC42NjcsMC0xLjI4My0wLjIzMy0xLjg1LTAuN0w1Ljc1LDc3LjVDNS4yNSw3Nyw1LDc2LjQxNyw1LDc1Ljc1YzAtMC43MzMsMC4yNS0xLjMzMywwLjc1LTEuOCAgTDI5LjY1LDUwTDUuNzUsMjYuMTAxQzUuMjUsMjUuNjY3LDUsMjUuMDY2LDUsMjQuM2MwLTAuNjY2LDAuMjUtMS4yNSwwLjc1LTEuNzVsMTYuOC0xNi44YzAuNDY3LTAuNDY3LDEuMDUtMC43LDEuNzUtMC43ICBjMC43MzMsMCwxLjMzMywwLjIzMywxLjgsMC43TDUwLDI5LjY1TDczLjksNS43NXpcIlxuICAgIH0pKSkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIGhlaWdodDogJzYwcHgnLFxuICAgICAgICB3aWR0aDogJ2NhbGMoMTAwJSAtIDYwcHgpJyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9LFxuICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrXG4gICAgfSwgdGhpcy5yZW5kZXJFcnJvck1lc3NhZ2UoKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIG5hbWU6IFwiYm9keVwiLFxuICAgICAgaWQ6IGlkICYmIGlkICsgJy1ib2R5JyxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBvdmVyZmxvdzogJ25vbmUnLFxuICAgICAgICBoZWlnaHQ6IGhhc0Vycm9yID8gJ2NhbGMoMTAwJSAtIDYwcHgpJyA6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHJlc2l6ZTogJ25vbmUnLFxuICAgICAgICBmb250RmFtaWx5OiAnUm9ib3RvIE1vbm8sIE1vbmFjbywgbW9ub3NwYWNlJyxcbiAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMuYmFja2dyb3VuZCxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAnMC4ycycsXG4gICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJ2N1YmljLWJlemllcigwLCAxLCAwLjUsIDEpJ1xuICAgICAgfSwgc3R5bGUuYm9keSksXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBuYW1lOiBcImxhYmVsc1wiLFxuICAgICAgaWQ6IGlkICYmIGlkICsgJy1sYWJlbHMnLFxuICAgICAgcmVmOiByZWYgPT4gdGhpcy5yZWZMYWJlbHMgPSByZWYsXG4gICAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICB3aWR0aDogJzQ0cHgnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6ICc1cHggMHB4IDVweCAxMHB4JyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBjb2xvcjogJyNENEQ0RDQnXG4gICAgICB9LCBzdHlsZS5sYWJlbENvbHVtbiksXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICB9LCB0aGlzLnJlbmRlckxhYmVscygpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgcmVmOiByZWYgPT4gdGhpcy5yZWZDb250ZW50ID0gcmVmLFxuICAgICAgY29udGVudEVkaXRhYmxlOiB0cnVlLFxuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICBmbGV4OiAxLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6ICc1cHgnLFxuICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxuICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgICAgICAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcbiAgICAgICAgd2hpdGVTcGFjZTogJ3ByZS1saW5lJyxcbiAgICAgICAgY29sb3I6ICcjRDRENEQ0JyxcbiAgICAgICAgb3V0bGluZTogJ25vbmUnXG4gICAgICB9LCBzdHlsZS5jb250ZW50Qm94KSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0aGlzLmNyZWF0ZU1hcmt1cChtYXJrdXBUZXh0KSxcbiAgICAgIG9uS2V5UHJlc3M6IHRoaXMub25LZXlQcmVzcyxcbiAgICAgIG9uS2V5RG93bjogdGhpcy5vbktleURvd24sXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2ssXG4gICAgICBvbkJsdXI6IHRoaXMub25CbHVyLFxuICAgICAgb25TY3JvbGw6IHRoaXMub25TY3JvbGwsXG4gICAgICBvblBhc3RlOiB0aGlzLm9uUGFzdGUsXG4gICAgICBhdXRvQ29tcGxldGU6IFwib2ZmXCIsXG4gICAgICBhdXRvQ29ycmVjdDogXCJvZmZcIixcbiAgICAgIGF1dG9DYXBpdGFsaXplOiBcIm9mZlwiLFxuICAgICAgc3BlbGxDaGVjazogZmFsc2VcbiAgICB9KSkpKTtcbiAgfVxuXG4gIHJlbmRlckVycm9yTWVzc2FnZSgpIHtcbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLnByb3BzLmxvY2FsZSB8fCBkZWZhdWx0TG9jYWxlLFxuICAgICAgICAgIGVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgaWYgKCFlcnJvcikgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwge1xuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB3aWR0aDogJ2NhbGMoMTAwJSAtIDYwcHgpJyxcbiAgICAgICAgaGVpZ2h0OiAnNjBweCcsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIHBhZGRpbmdSaWdodDogJzEwcHgnLFxuICAgICAgICBvdmVyZmxvd1dyYXA6ICdicmVhay13b3JkJyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgICB9LCBzdHlsZS5lcnJvck1lc3NhZ2UpXG4gICAgfSwgZm9ybWF0KGxvY2FsZS5mb3JtYXQsIGVycm9yKSk7XG4gIH1cblxuICByZW5kZXJMYWJlbHMoKSB7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5jb2xvcnMsXG4gICAgICAgICAgc3R5bGUgPSB0aGlzLnN0eWxlLFxuICAgICAgICAgIGVycm9yTGluZSA9IHRoaXMuc3RhdGUuZXJyb3IgPyB0aGlzLnN0YXRlLmVycm9yLmxpbmUgOiAtMSxcbiAgICAgICAgICBsaW5lcyA9IHRoaXMuc3RhdGUubGluZXMgPyB0aGlzLnN0YXRlLmxpbmVzIDogMTtcbiAgICBsZXQgbGFiZWxzID0gbmV3IEFycmF5KGxpbmVzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMgLSAxOyBpKyspIGxhYmVsc1tpXSA9IGkgKyAxO1xuXG4gICAgcmV0dXJuIGxhYmVscy5tYXAobnVtYmVyID0+IHtcbiAgICAgIGNvbnN0IGNvbG9yID0gbnVtYmVyICE9PSBlcnJvckxpbmUgPyBjb2xvcnMuZGVmYXVsdCA6ICdyZWQnO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IG51bWJlcixcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe30sIHN0eWxlLmxhYmVscywge1xuICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9KVxuICAgICAgfSwgbnVtYmVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZU1hcmt1cChtYXJrdXBUZXh0KSB7XG4gICAgaWYgKG1hcmt1cFRleHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHtcbiAgICAgIF9faHRtbDogJydcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBfX2h0bWw6ICcnICsgbWFya3VwVGV4dFxuICAgIH07XG4gIH1cblxuICBuZXdTcGFuKGksIHRva2VuLCBkZXB0aCkge1xuICAgIGxldCBjb2xvcnMgPSB0aGlzLmNvbG9ycyxcbiAgICAgICAgdHlwZSA9IHRva2VuLnR5cGUsXG4gICAgICAgIHN0cmluZyA9IHRva2VuLnN0cmluZztcbiAgICBsZXQgY29sb3IgPSAnJztcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdwcmltaXRpdmUnOlxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjb2xvciA9IGNvbG9yc1t0b2tlbi50eXBlXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgIGlmIChzdHJpbmcgPT09ICcgJykgY29sb3IgPSBjb2xvcnMua2V5c193aGl0ZVNwYWNlO2Vsc2UgY29sb3IgPSBjb2xvcnMua2V5cztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgIGlmIChzdHJpbmcgPT09ICc6JykgY29sb3IgPSBjb2xvcnMuY29sb247ZWxzZSBjb2xvciA9IGNvbG9ycy5kZWZhdWx0O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29sb3IgPSBjb2xvcnMuZGVmYXVsdDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0cmluZy5sZW5ndGggIT09IHN0cmluZy5yZXBsYWNlKC88L2csICcnKS5yZXBsYWNlKC8+L2csICcnKS5sZW5ndGgpIHN0cmluZyA9ICc8eG1wIHN0eWxlPWRpc3BsYXk6aW5saW5lOz4nICsgc3RyaW5nICsgJzwveG1wPic7XG4gICAgcmV0dXJuICc8c3BhbicgKyAnIHR5cGU9XCInICsgdHlwZSArICdcIicgKyAnIHZhbHVlPVwiJyArIHN0cmluZyArICdcIicgKyAnIGRlcHRoPVwiJyArIGRlcHRoICsgJ1wiJyArICcgc3R5bGU9XCJjb2xvcjonICsgY29sb3IgKyAnXCInICsgJz4nICsgc3RyaW5nICsgJzwvc3Bhbj4nO1xuICB9XG5cbiAgZ2V0Q3Vyc29yUG9zaXRpb24oY291bnRCUikge1xuICAgIC8qKlxyXG4gICAgICogTmVlZCB0byBkZXByZWNhdGUgY291bnRCUlxyXG4gICAgICogSXQgaXMgdXNlZCB0byBkaWZmZXJlbmNpYXRlIGJldHdlZW4gZ29vZCBtYXJrdXAgcmVuZGVyLCBhbmQgYXV4IHJlbmRlciB3aGVuIGVycm9yIGZvdW5kXHJcbiAgICAgKiBBZGp1c3RtZW50cyBiYXNlZCBvbiBjb3VuZEJSIGFjY291bnQgZm9yIHVzYWdlIG9mIDxicj4gaW5zdGVhZCBvZiA8c3Bhbj4gZm9yIGxpbmVicmVha3MgdG8gZGV0ZXJtaW5lIGFjdXJhdGUgY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgKiBGaW5kIGEgd2F5IHRvIGNvbnNvbGlkYXRlIHJlbmRlciBzdHlsZXNcclxuICAgICAqL1xuICAgIGNvbnN0IGlzQ2hpbGRPZiA9IG5vZGUgPT4ge1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMucmVmQ29udGVudCkgcmV0dXJuIHRydWU7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgbGV0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgY2hhckNvdW50ID0gLTEsXG4gICAgICAgIGxpbmVicmVha0NvdW50ID0gMCxcbiAgICAgICAgbm9kZTtcblxuICAgIGlmIChzZWxlY3Rpb24uZm9jdXNOb2RlICYmIGlzQ2hpbGRPZihzZWxlY3Rpb24uZm9jdXNOb2RlKSkge1xuICAgICAgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgICBjaGFyQ291bnQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnJlZkNvbnRlbnQpIGJyZWFrO1xuXG4gICAgICAgIGlmIChub2RlLnByZXZpb3VzU2libGluZykge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBpZiAoY291bnRCUikgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdCUicpIGxpbmVicmVha0NvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50ICs9IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJDb3VudCArIGxpbmVicmVha0NvdW50O1xuICB9XG5cbiAgc2V0Q3Vyc29yUG9zaXRpb24obmV4dFBvc2l0aW9uKSB7XG4gICAgaWYgKFtmYWxzZSwgbnVsbCwgdW5kZWZpbmVkXS5pbmRleE9mKG5leHRQb3NpdGlvbikgPiAtMSkgcmV0dXJuO1xuXG4gICAgY29uc3QgY3JlYXRlUmFuZ2UgPSAobm9kZSwgY2hhcnMsIHJhbmdlKSA9PiB7XG4gICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFycy5jb3VudCA9PT0gMCkge1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgY2hhcnMuY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChub2RlICYmIGNoYXJzLmNvdW50ID4gMCkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBpZiAobm9kZS50ZXh0Q29udGVudC5sZW5ndGggPCBjaGFycy5jb3VudCkgY2hhcnMuY291bnQgLT0gbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7ZWxzZSB7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgY2hhcnMuY291bnQpO1xuICAgICAgICAgICAgY2hhcnMuY291bnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGZvciAodmFyIGxwID0gMDsgbHAgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBscCsrKSB7XG4gICAgICAgICAgcmFuZ2UgPSBjcmVhdGVSYW5nZShub2RlLmNoaWxkTm9kZXNbbHBdLCBjaGFycywgcmFuZ2UpO1xuICAgICAgICAgIGlmIChjaGFycy5jb3VudCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXRQb3NpdGlvbiA9IGNoYXJzID0+IHtcbiAgICAgIGlmIChjaGFycyA8IDApIHJldHVybjtcbiAgICAgIGxldCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgcmFuZ2UgPSBjcmVhdGVSYW5nZSh0aGlzLnJlZkNvbnRlbnQsIHtcbiAgICAgICAgY291bnQ6IGNoYXJzXG4gICAgICB9KTtcbiAgICAgIGlmICghcmFuZ2UpIHJldHVybjtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfTtcblxuICAgIGlmIChuZXh0UG9zaXRpb24gPiAwKSBzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO2Vsc2UgdGhpcy5yZWZDb250ZW50LmZvY3VzKCk7XG4gIH1cblxuICB1cGRhdGUoY3Vyc29yT2Zmc2V0ID0gMCwgdXBkYXRlQ3Vyc29yUG9zaXRpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5yZWZDb250ZW50LFxuICAgICAgICAgIGRhdGEgPSB0aGlzLnRva2VuaXplKGNvbnRhaW5lcik7XG4gICAgaWYgKCdvbkNoYW5nZScgaW4gdGhpcy5wcm9wcykgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICBwbGFpblRleHQ6IGRhdGEuaW5kZW50ZWQsXG4gICAgICBtYXJrdXBUZXh0OiBkYXRhLm1hcmt1cCxcbiAgICAgIGpzb246IGRhdGEuanNvbixcbiAgICAgIGpzT2JqZWN0OiBkYXRhLmpzT2JqZWN0LFxuICAgICAgbGluZXM6IGRhdGEubGluZXMsXG4gICAgICBlcnJvcjogZGF0YS5lcnJvclxuICAgIH0pO1xuICAgIGxldCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oZGF0YS5lcnJvcikgKyBjdXJzb3JPZmZzZXQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwbGFpblRleHQ6IGRhdGEuaW5kZW50ZWQsXG4gICAgICBtYXJrdXBUZXh0OiBkYXRhLm1hcmt1cCxcbiAgICAgIGpzb246IGRhdGEuanNvbixcbiAgICAgIGpzT2JqZWN0OiBkYXRhLmpzT2JqZWN0LFxuICAgICAgbGluZXM6IGRhdGEubGluZXMsXG4gICAgICBlcnJvcjogZGF0YS5lcnJvclxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVGltZSA9IGZhbHNlO1xuICAgIGlmICh1cGRhdGVDdXJzb3JQb3NpdGlvbikgdGhpcy5zZXRDdXJzb3JQb3NpdGlvbihjdXJzb3JQb3NpdGlvbik7XG4gIH1cblxuICBzY2hlZHVsZWRVcGRhdGUoKSB7XG4gICAgaWYgKCdvbktleVByZXNzVXBkYXRlJyBpbiB0aGlzLnByb3BzKSBpZiAodGhpcy5wcm9wcy5vbktleVByZXNzVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHVwZGF0ZVRpbWVcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodXBkYXRlVGltZSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICBpZiAodXBkYXRlVGltZSA+IG5ldyBEYXRlKCkuZ2V0VGltZSgpKSByZXR1cm47XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHNldFVwZGF0ZVRpbWUoKSB7XG4gICAgaWYgKCdvbktleVByZXNzVXBkYXRlJyBpbiB0aGlzLnByb3BzKSBpZiAodGhpcy5wcm9wcy5vbktleVByZXNzVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy53YWl0QWZ0ZXJLZXlQcmVzcztcbiAgfVxuXG4gIHN0b3BFdmVudChldmVudCkge1xuICAgIGlmICghZXZlbnQpIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgb25LZXlQcmVzcyhldmVudCkge1xuICAgIGNvbnN0IGN0cmxPck1ldGFJc1ByZXNzZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG4gICAgaWYgKHRoaXMucHJvcHMudmlld09ubHkgJiYgIWN0cmxPck1ldGFJc1ByZXNzZWQpIHRoaXMuc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAoIWN0cmxPck1ldGFJc1ByZXNzZWQpIHRoaXMuc2V0VXBkYXRlVGltZSgpO1xuICB9XG5cbiAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgY29uc3Qgdmlld09ubHkgPSAhIXRoaXMucHJvcHMudmlld09ubHk7XG4gICAgY29uc3QgY3RybE9yTWV0YUlzUHJlc3NlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblxuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlICdUYWInOlxuICAgICAgICB0aGlzLnN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGlmICh2aWV3T25seSkgYnJlYWs7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5zZXJ0VGV4dFwiLCBmYWxzZSwgXCIgIFwiKTtcbiAgICAgICAgdGhpcy5zZXRVcGRhdGVUaW1lKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgY2FzZSAnRGVsZXRlJzpcbiAgICAgICAgaWYgKHZpZXdPbmx5KSB0aGlzLnN0b3BFdmVudChldmVudCk7XG4gICAgICAgIHRoaXMuc2V0VXBkYXRlVGltZSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICB0aGlzLnNldFVwZGF0ZVRpbWUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmICh2aWV3T25seSAmJiAhY3RybE9yTWV0YUlzUHJlc3NlZCkgdGhpcy5zdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHZpZXdPbmx5KSB0aGlzLnN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uUGFzdGUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy52aWV3T25seSkge1xuICAgICAgdGhpcy5zdG9wRXZlbnQoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRIVE1MJywgZmFsc2UsIHRleHQpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBvbkNsaWNrKCkge1xuICAgIGlmICgndmlld09ubHknIGluIHRoaXMucHJvcHMpIGlmICh0aGlzLnByb3BzLnZpZXdPbmx5KSByZXR1cm47XG4gIH1cblxuICBvbkJsdXIoKSB7XG4gICAgaWYgKCd2aWV3T25seScgaW4gdGhpcy5wcm9wcykgaWYgKHRoaXMucHJvcHMudmlld09ubHkpIHJldHVybjtcbiAgICB0aGlzLnVwZGF0ZSgwLCBmYWxzZSk7XG4gIH1cblxuICBvblNjcm9sbChldmVudCkge1xuICAgIHRoaXMucmVmTGFiZWxzLnNjcm9sbFRvcCA9IGV2ZW50LnRhcmdldC5zY3JvbGxUb3A7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVJbnRlcm5hbFByb3BzKCk7XG4gICAgdGhpcy5zaG93UGxhY2Vob2xkZXIoKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2hvd1BsYWNlaG9sZGVyKCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy50aW1lcikgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgfVxuXG4gIHNob3dQbGFjZWhvbGRlcigpIHtcbiAgICBjb25zdCBwbGFjZWhvbGRlckRvZXNOb3RFeGlzdCA9ICEoJ3BsYWNlaG9sZGVyJyBpbiB0aGlzLnByb3BzKTtcbiAgICBpZiAocGxhY2Vob2xkZXJEb2VzTm90RXhpc3QpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBwbGFjZWhvbGRlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVySGFzRW1wdHlWYWx1ZXMgPSBbdW5kZWZpbmVkLCBudWxsXS5pbmRleE9mKHBsYWNlaG9sZGVyKSA+IC0xO1xuICAgIGlmIChwbGFjZWhvbGRlckhhc0VtcHR5VmFsdWVzKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgcHJldlBsYWNlaG9sZGVyLFxuICAgICAganNPYmplY3RcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICByZXNldENvbmZpZ3VyYXRpb25cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBwbGFjZWhvbGRlckRhdGFUeXBlID0gZ2V0VHlwZShwbGFjZWhvbGRlcik7XG4gICAgY29uc3QgdW5leHBlY3RlZERhdGFUeXBlID0gWydvYmplY3QnLCAnYXJyYXknXS5pbmRleE9mKHBsYWNlaG9sZGVyRGF0YVR5cGUpID09PSAtMTtcbiAgICBpZiAodW5leHBlY3RlZERhdGFUeXBlKSBlcnIudGhyb3dFcnJvcignc2hvd1BsYWNlaG9sZGVyJywgJ3BsYWNlaG9sZGVyJywgJ2VpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKTtcbiAgICBjb25zdCBzYW1lUGxhY2Vob2xkZXJWYWx1ZXMgPSBpZGVudGljYWwocGxhY2Vob2xkZXIsIHByZXZQbGFjZWhvbGRlcik7IC8vIENvbXBvbmVudCB3aWxsIGFsd2F5cyByZS1yZW5kZXIgd2hlbiBuZXcgcGxhY2Vob2xkZXIgdmFsdWUgaXMgYW55IGRpZmZlcmVudCBmcm9tIHByZXZpb3VzIHBsYWNlaG9sZGVyIHZhbHVlLiBcblxuICAgIGxldCBjb21wb25lbnRTaG91bGRVcGRhdGUgPSAhc2FtZVBsYWNlaG9sZGVyVmFsdWVzO1xuXG4gICAgaWYgKCFjb21wb25lbnRTaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmIChyZXNldENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgJ3Jlc2V0JyBwcm9wZXJ0eSBpcyBzZXQgdHJ1ZSBvciBpcyB0cnV0aHksXHJcbiAgICAgICAgICogYW55IGRpZmZlcmVuY2UgYmV0d2VlbiBwbGFjZWhvbGRlciBhbmQgY3VycmVudCB2YWx1ZVxyXG4gICAgICAgICAqIHNob3VsZCB0cmlnZ2VyIGNvbXBvbmVudCByZS1yZW5kZXJcclxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGpzT2JqZWN0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudFNob3VsZFVwZGF0ZSA9ICFpZGVudGljYWwocGxhY2Vob2xkZXIsIGpzT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbXBvbmVudFNob3VsZFVwZGF0ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnRva2VuaXplKHBsYWNlaG9sZGVyKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHByZXZQbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICBwbGFpblRleHQ6IGRhdGEuaW5kZW50YXRpb24sXG4gICAgICBtYXJrdXBUZXh0OiBkYXRhLm1hcmt1cCxcbiAgICAgIGxpbmVzOiBkYXRhLmxpbmVzLFxuICAgICAgZXJyb3I6IGRhdGEuZXJyb3JcbiAgICB9KTtcbiAgfVxuXG4gIHRva2VuaXplKHNvbWV0aGluZykge1xuICAgIGlmICh0eXBlb2Ygc29tZXRoaW5nICE9PSAnb2JqZWN0JykgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ3Rva2VuaXplKCkgZXhwZWN0cyBvYmplY3QgdHlwZSBwcm9wZXJ0aWVzIG9ubHkuIEdvdCBcXCcnICsgdHlwZW9mIHNvbWV0aGluZyArICdcXCcgdHlwZSBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMucHJvcHMubG9jYWxlIHx8IGRlZmF1bHRMb2NhbGU7XG4gICAgY29uc3QgbmV3U3BhbiA9IHRoaXMubmV3U3BhbjtcbiAgICAvKipcclxuICAgICAqICAgICBET00gTk9ERSB8fCBPTkJMVVIgT1IgVVBEQVRFXHJcbiAgICAgKi9cblxuICAgIGlmICgnbm9kZVR5cGUnIGluIHNvbWV0aGluZykge1xuICAgICAgY29uc3QgY29udGFpbmVyTm9kZSA9IHNvbWV0aGluZy5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgICBoYXNDaGlsZHJlbiA9IGNvbnRhaW5lck5vZGUuaGFzQ2hpbGROb2RlcygpO1xuICAgICAgaWYgKCFoYXNDaGlsZHJlbikgcmV0dXJuICcnO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjb250YWluZXJOb2RlLmNoaWxkTm9kZXM7XG4gICAgICBsZXQgYnVmZmVyID0ge1xuICAgICAgICB0b2tlbnNfdW5rbm93bjogW10sXG4gICAgICAgIHRva2Vuc19wcm90bzogW10sXG4gICAgICAgIHRva2Vuc19zcGxpdDogW10sXG4gICAgICAgIHRva2Vuc19mYWxsYmFjazogW10sXG4gICAgICAgIHRva2Vuc19ub3JtYWxpemU6IFtdLFxuICAgICAgICB0b2tlbnNfbWVyZ2U6IFtdLFxuICAgICAgICB0b2tlbnNfcGxhaW5UZXh0OiAnJyxcbiAgICAgICAgaW5kZW50ZWQ6ICcnLFxuICAgICAgICBqc29uOiAnJyxcbiAgICAgICAganNPYmplY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgbWFya3VwOiAnJ1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgbGV0IGluZm8gPSB7fTtcblxuICAgICAgICBzd2l0Y2ggKGNoaWxkLm5vZGVOYW1lKSB7XG4gICAgICAgICAgY2FzZSAnU1BBTic6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICBzdHJpbmc6IGNoaWxkLnRleHRDb250ZW50LFxuICAgICAgICAgICAgICB0eXBlOiBjaGlsZC5hdHRyaWJ1dGVzLnR5cGUudGV4dENvbnRlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBidWZmZXIudG9rZW5zX3Vua25vd24ucHVzaChpbmZvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRElWJzpcbiAgICAgICAgICAgIGJ1ZmZlci50b2tlbnNfdW5rbm93bi5wdXNoKHtcbiAgICAgICAgICAgICAgc3RyaW5nOiBjaGlsZC50ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgdHlwZTogJ3Vua25vd24nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQlInOlxuICAgICAgICAgICAgaWYgKGNoaWxkLnRleHRDb250ZW50ID09PSAnJykgYnVmZmVyLnRva2Vuc191bmtub3duLnB1c2goe1xuICAgICAgICAgICAgICBzdHJpbmc6ICdcXG4nLFxuICAgICAgICAgICAgICB0eXBlOiAndW5rbm93bidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcjdGV4dCc6XG4gICAgICAgICAgICBidWZmZXIudG9rZW5zX3Vua25vd24ucHVzaCh7XG4gICAgICAgICAgICAgIHN0cmluZzogY2hpbGQud2hvbGVUZXh0LFxuICAgICAgICAgICAgICB0eXBlOiAndW5rbm93bidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdGT05UJzpcbiAgICAgICAgICAgIGJ1ZmZlci50b2tlbnNfdW5rbm93bi5wdXNoKHtcbiAgICAgICAgICAgICAgc3RyaW5nOiBjaGlsZC50ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgdHlwZTogJ3Vua25vd24nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VucmVjb2duaXplZCBub2RlOicsIHtcbiAgICAgICAgICAgICAgY2hpbGRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcXVhcmtpemUodGV4dCwgcHJlZml4ID0gJycpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHtcbiAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIHN0cmluZzogJycsXG4gICAgICAgICAgbnVtYmVyOiAnJyxcbiAgICAgICAgICBzeW1ib2w6ICcnLFxuICAgICAgICAgIHNwYWNlOiAnJyxcbiAgICAgICAgICBkZWxpbWl0ZXI6ICcnLFxuICAgICAgICAgIHF1YXJrczogW11cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwdXNoQW5kU3RvcmUoY2hhciwgdHlwZSkge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIGNhc2UgJ2RlbGltaXRlcic6XG4gICAgICAgICAgICAgIGlmIChidWZmZXIuYWN0aXZlKSBidWZmZXIucXVhcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0cmluZzogYnVmZmVyW2J1ZmZlci5hY3RpdmVdLFxuICAgICAgICAgICAgICAgIHR5cGU6IHByZWZpeCArICctJyArIGJ1ZmZlci5hY3RpdmVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcltidWZmZXIuYWN0aXZlXSA9ICcnO1xuICAgICAgICAgICAgICBidWZmZXIuYWN0aXZlID0gdHlwZTtcbiAgICAgICAgICAgICAgYnVmZmVyW2J1ZmZlci5hY3RpdmVdID0gY2hhcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0eXBlICE9PSBidWZmZXIuYWN0aXZlIHx8IFtidWZmZXIuc3RyaW5nLCBjaGFyXS5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5hY3RpdmUpIGJ1ZmZlci5xdWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICBzdHJpbmc6IGJ1ZmZlcltidWZmZXIuYWN0aXZlXSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHByZWZpeCArICctJyArIGJ1ZmZlci5hY3RpdmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBidWZmZXJbYnVmZmVyLmFjdGl2ZV0gPSAnJztcbiAgICAgICAgICAgICAgICBidWZmZXIuYWN0aXZlID0gdHlwZTtcbiAgICAgICAgICAgICAgICBidWZmZXJbYnVmZmVyLmFjdGl2ZV0gPSBjaGFyO1xuICAgICAgICAgICAgICB9IGVsc2UgYnVmZmVyW3R5cGVdICs9IGNoYXI7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluYWxQdXNoKCkge1xuICAgICAgICAgIGlmIChidWZmZXIuYWN0aXZlKSB7XG4gICAgICAgICAgICBidWZmZXIucXVhcmtzLnB1c2goe1xuICAgICAgICAgICAgICBzdHJpbmc6IGJ1ZmZlcltidWZmZXIuYWN0aXZlXSxcbiAgICAgICAgICAgICAgdHlwZTogcHJlZml4ICsgJy0nICsgYnVmZmVyLmFjdGl2ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBidWZmZXJbYnVmZmVyLmFjdGl2ZV0gPSAnJztcbiAgICAgICAgICAgIGJ1ZmZlci5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFyID0gdGV4dC5jaGFyQXQoaSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICAgIHB1c2hBbmRTdG9yZShjaGFyLCAnZGVsaW1pdGVyJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIGNhc2UgJ1xcdTAwQTAnOlxuICAgICAgICAgICAgICBwdXNoQW5kU3RvcmUoY2hhciwgJ3NwYWNlJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICAgIHB1c2hBbmRTdG9yZShjaGFyLCAnc3ltYm9sJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgICBjYXNlICc2JzpcbiAgICAgICAgICAgIGNhc2UgJzcnOlxuICAgICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5hY3RpdmUgPT09ICdzdHJpbmcnKSBwdXNoQW5kU3RvcmUoY2hhciwgJ3N0cmluZycpO2Vsc2UgcHVzaEFuZFN0b3JlKGNoYXIsICdudW1iZXInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICBpZiAoaSA8IHRleHQubGVuZ3RoIC0gMSkgaWYgKCcwMTIzNDU2Nzg5Jy5pbmRleE9mKHRleHQuY2hhckF0KGkgKyAxKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHB1c2hBbmRTdG9yZShjaGFyLCAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgIGlmIChpIDwgdGV4dC5sZW5ndGggLSAxICYmIGkgPiAwKSBpZiAoJzAxMjM0NTY3ODknLmluZGV4T2YodGV4dC5jaGFyQXQoaSArIDEpKSA+IC0xICYmICcwMTIzNDU2Nzg5Jy5pbmRleE9mKHRleHQuY2hhckF0KGkgLSAxKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHB1c2hBbmRTdG9yZShjaGFyLCAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcHVzaEFuZFN0b3JlKGNoYXIsICdzdHJpbmcnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxQdXNoKCk7XG4gICAgICAgIHJldHVybiBidWZmZXIucXVhcmtzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci50b2tlbnNfdW5rbm93bi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdG9rZW4gPSBidWZmZXIudG9rZW5zX3Vua25vd25baV07XG4gICAgICAgIGJ1ZmZlci50b2tlbnNfcHJvdG8gPSBidWZmZXIudG9rZW5zX3Byb3RvLmNvbmNhdChxdWFya2l6ZSh0b2tlbi5zdHJpbmcsICdwcm90bycpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRUb2tlbihzdHJpbmcsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgcXVvdGVzID0gJ1xcJ1wiJztcbiAgICAgICAgbGV0IGZpcnN0Q2hhciA9ICcnLFxuICAgICAgICAgICAgbGFzdENoYXIgPSAnJyxcbiAgICAgICAgICAgIHF1b3RlVHlwZSA9IGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3ByaW1pdGl2ZSc6XG4gICAgICAgICAgICBpZiAoWyd0cnVlJywgJ2ZhbHNlJywgJ251bGwnLCAndW5kZWZpbmVkJ10uaW5kZXhPZihzdHJpbmcpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmaXJzdENoYXIgPSBzdHJpbmcuY2hhckF0KDApLCBsYXN0Q2hhciA9IHN0cmluZy5jaGFyQXQoc3RyaW5nLmxlbmd0aCAtIDEpLCBxdW90ZVR5cGUgPSBxdW90ZXMuaW5kZXhPZihmaXJzdENoYXIpO1xuICAgICAgICAgICAgaWYgKHF1b3RlVHlwZSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgIT09IGxhc3RDaGFyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChpID4gMCAmJiBpIDwgc3RyaW5nLmxlbmd0aCAtIDEpIGlmIChzdHJpbmcuY2hhckF0KGkpID09PSBxdW90ZXNbcXVvdGVUeXBlXSkgaWYgKHN0cmluZy5jaGFyQXQoaSAtIDEpICE9PSAnXFxcXCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZpcnN0Q2hhciA9IHN0cmluZy5jaGFyQXQoMCksIGxhc3RDaGFyID0gc3RyaW5nLmNoYXJBdChzdHJpbmcubGVuZ3RoIC0gMSksIHF1b3RlVHlwZSA9IHF1b3Rlcy5pbmRleE9mKGZpcnN0Q2hhcik7XG5cbiAgICAgICAgICAgIGlmIChxdW90ZVR5cGUgPiAtMSkge1xuICAgICAgICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoZmlyc3RDaGFyICE9PSBsYXN0Q2hhcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBzdHJpbmcubGVuZ3RoIC0gMSkgaWYgKHN0cmluZy5jaGFyQXQoaSkgPT09IHF1b3Rlc1txdW90ZVR5cGVdKSBpZiAoc3RyaW5nLmNoYXJBdChpIC0gMSkgIT09ICdcXFxcJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBub25BbHBoYW51bWVyaWMgPSAnXFwnXCJgLiw6O3t9W10mPD49fiolXFxcXHwvLSshP0BeIFxceGEwJztcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkFscGhhbnVtZXJpYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vbkFscGhhID0gbm9uQWxwaGFudW1lcmljLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2Yobm9uQWxwaGEpID4gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoJzAxMjM0NTY3ODknLmluZGV4T2Yoc3RyaW5nLmNoYXJBdChpKSkgPT09IC0xKSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgnLScgIT09IHN0cmluZy5jaGFyQXQoMCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgnLicgIT09IHN0cmluZy5jaGFyQXQoaSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoJ3tbOl19LCcuaW5kZXhPZihzdHJpbmcpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjb2xvbic6XG4gICAgICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICgnOicgIT09IHN0cmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci50b2tlbnNfcHJvdG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRva2VuID0gYnVmZmVyLnRva2Vuc19wcm90b1tpXTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZS5pbmRleE9mKCdwcm90bycpID09PSAtMSkge1xuICAgICAgICAgIGlmICghdmFsaWRUb2tlbih0b2tlbi5zdHJpbmcsIHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICBidWZmZXIudG9rZW5zX3NwbGl0ID0gYnVmZmVyLnRva2Vuc19zcGxpdC5jb25jYXQocXVhcmtpemUodG9rZW4uc3RyaW5nLCAnc3BsaXQnKSk7XG4gICAgICAgICAgfSBlbHNlIGJ1ZmZlci50b2tlbnNfc3BsaXQucHVzaCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBidWZmZXIudG9rZW5zX3NwbGl0LnB1c2godG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci50b2tlbnNfc3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRva2VuID0gYnVmZmVyLnRva2Vuc19zcGxpdFtpXTtcbiAgICAgICAgbGV0IHR5cGUgPSB0b2tlbi50eXBlLFxuICAgICAgICAgICAgc3RyaW5nID0gdG9rZW4uc3RyaW5nLFxuICAgICAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIGZhbGxiYWNrID0gW107XG5cbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICB0eXBlID0gdHlwZS5zbGljZSh0eXBlLmluZGV4T2YoJy0nKSArIDEpO1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykgZmFsbGJhY2sucHVzaCgnc3RyaW5nJyk7XG4gICAgICAgICAgZmFsbGJhY2sucHVzaCgna2V5Jyk7XG4gICAgICAgICAgZmFsbGJhY2sucHVzaCgnZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b2t1bCA9IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIGZhbGxiYWNrOiBmYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICBidWZmZXIudG9rZW5zX2ZhbGxiYWNrLnB1c2godG9rdWwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b2tlbkZvbGxvd2VkKCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gYnVmZmVyLnRva2Vuc19ub3JtYWxpemUubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IGJ1ZmZlci50b2tlbnNfbm9ybWFsaXplW2ldO1xuXG4gICAgICAgICAgc3dpdGNoIChwcmV2aW91c1Rva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2xpbmVicmVhayc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNUb2tlbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgYnVmZmVyMiA9IHtcbiAgICAgICAgYnJhY2tldHM6IFtdLFxuICAgICAgICBzdHJpbmdPcGVuOiBmYWxzZSxcbiAgICAgICAgaXNWYWx1ZTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLnRva2Vuc19mYWxsYmFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdG9rZW4gPSBidWZmZXIudG9rZW5zX2ZhbGxiYWNrW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gdG9rZW4udHlwZSxcbiAgICAgICAgICAgICAgc3RyaW5nID0gdG9rZW4uc3RyaW5nO1xuICAgICAgICBsZXQgbm9ybWFsVG9rZW4gPSB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgY2FzZSAnY29sb24nOlxuICAgICAgICAgICAgaWYgKGJ1ZmZlcjIuc3RyaW5nT3Blbikge1xuICAgICAgICAgICAgICBpZiAoYnVmZmVyMi5pc1ZhbHVlKSBub3JtYWxUb2tlbi50eXBlID0gJ3N0cmluZyc7ZWxzZSBub3JtYWxUb2tlbi50eXBlID0gJ2tleSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmluZykge1xuICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgYnVmZmVyMi5icmFja2V0cy5wdXNoKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgYnVmZmVyMi5pc1ZhbHVlID0gYnVmZmVyMi5icmFja2V0c1tidWZmZXIyLmJyYWNrZXRzLmxlbmd0aCAtIDFdID09PSAnWyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgICAgIGJ1ZmZlcjIuYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyMi5pc1ZhbHVlID0gYnVmZmVyMi5icmFja2V0c1tidWZmZXIyLmJyYWNrZXRzLmxlbmd0aCAtIDFdID09PSAnWyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuRm9sbG93ZWQoKS50eXBlID09PSAnY29sb24nKSBicmVhaztcbiAgICAgICAgICAgICAgICBidWZmZXIyLmlzVmFsdWUgPSBidWZmZXIyLmJyYWNrZXRzW2J1ZmZlcjIuYnJhY2tldHMubGVuZ3RoIC0gMV0gPT09ICdbJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgICAgICBub3JtYWxUb2tlbi50eXBlID0gJ2NvbG9uJztcbiAgICAgICAgICAgICAgICBidWZmZXIyLmlzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2RlbGltaXRlcic6XG4gICAgICAgICAgICBpZiAoYnVmZmVyMi5pc1ZhbHVlKSBub3JtYWxUb2tlbi50eXBlID0gJ3N0cmluZyc7ZWxzZSBub3JtYWxUb2tlbi50eXBlID0gJ2tleSc7XG5cbiAgICAgICAgICAgIGlmICghYnVmZmVyMi5zdHJpbmdPcGVuKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjIuc3RyaW5nT3BlbiA9IHN0cmluZztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Rva2VuID0gYnVmZmVyLnRva2Vuc19mYWxsYmFja1tpIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgIF9zdHJpbmcgPSBwcmV2aW91c1Rva2VuLnN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgX3R5cGUgPSBwcmV2aW91c1Rva2VuLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIF9jaGFyID0gX3N0cmluZy5jaGFyQXQoX3N0cmluZy5sZW5ndGggLSAxKTtcblxuICAgICAgICAgICAgICBpZiAoX3R5cGUgPT09ICdzdHJpbmcnICYmIF9jaGFyID09PSAnXFxcXCcpIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYnVmZmVyMi5zdHJpbmdPcGVuID09PSBzdHJpbmcpIHtcbiAgICAgICAgICAgICAgYnVmZmVyMi5zdHJpbmdPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3ByaW1pdGl2ZSc6XG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGlmIChbJ2ZhbHNlJywgJ3RydWUnLCAnbnVsbCcsICd1bmRlZmluZWQnXS5pbmRleE9mKHN0cmluZykgPiAtMSkge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBidWZmZXIudG9rZW5zX25vcm1hbGl6ZS5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIudG9rZW5zX25vcm1hbGl6ZVtsYXN0SW5kZXhdLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICBub3JtYWxUb2tlbi50eXBlID0gJ3ByaW1pdGl2ZSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub3JtYWxUb2tlbi50eXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBub3JtYWxUb2tlbi50eXBlID0gJ3ByaW1pdGl2ZSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RyaW5nID09PSAnXFxuJykgaWYgKCFidWZmZXIyLnN0cmluZ09wZW4pIHtcbiAgICAgICAgICAgICAgbm9ybWFsVG9rZW4udHlwZSA9ICdsaW5lYnJlYWsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIyLmlzVmFsdWUpIG5vcm1hbFRva2VuLnR5cGUgPSAnc3RyaW5nJztlbHNlIG5vcm1hbFRva2VuLnR5cGUgPSAna2V5JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgaWYgKGJ1ZmZlcjIuc3RyaW5nT3BlbikgaWYgKGJ1ZmZlcjIuaXNWYWx1ZSkgbm9ybWFsVG9rZW4udHlwZSA9ICdzdHJpbmcnO2Vsc2Ugbm9ybWFsVG9rZW4udHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgaWYgKGJ1ZmZlcjIuc3RyaW5nT3BlbikgaWYgKGJ1ZmZlcjIuaXNWYWx1ZSkgbm9ybWFsVG9rZW4udHlwZSA9ICdzdHJpbmcnO2Vsc2Ugbm9ybWFsVG9rZW4udHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIudG9rZW5zX25vcm1hbGl6ZS5wdXNoKG5vcm1hbFRva2VuKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIudG9rZW5zX25vcm1hbGl6ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGJ1ZmZlci50b2tlbnNfbm9ybWFsaXplW2ldO1xuICAgICAgICBsZXQgbWVyZ2VkVG9rZW4gPSB7XG4gICAgICAgICAgc3RyaW5nOiB0b2tlbi5zdHJpbmcsXG4gICAgICAgICAgdHlwZTogdG9rZW4udHlwZSxcbiAgICAgICAgICB0b2tlbnM6IFtpXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoWydzeW1ib2wnLCAnY29sb24nXS5pbmRleE9mKHRva2VuLnR5cGUpID09PSAtMSkgaWYgKGkgKyAxIDwgYnVmZmVyLnRva2Vuc19ub3JtYWxpemUubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGNvdW50ID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIHUgPSBpICsgMTsgdSA8IGJ1ZmZlci50b2tlbnNfbm9ybWFsaXplLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSBidWZmZXIudG9rZW5zX25vcm1hbGl6ZVt1XTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBuZXh0VG9rZW4udHlwZSkgYnJlYWs7XG4gICAgICAgICAgICBtZXJnZWRUb2tlbi5zdHJpbmcgKz0gbmV4dFRva2VuLnN0cmluZztcbiAgICAgICAgICAgIG1lcmdlZFRva2VuLnRva2Vucy5wdXNoKHUpO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci50b2tlbnNfbWVyZ2UucHVzaChtZXJnZWRUb2tlbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHF1b3RlcyA9ICdcXCdcIicsXG4gICAgICAgICAgICBhbHBoYW51bWVyaWMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICcwMTIzNDU2Nzg5JyArICdfJCc7XG4gICAgICB2YXIgZXJyb3IgPSBmYWxzZSxcbiAgICAgICAgICBsaW5lID0gYnVmZmVyLnRva2Vuc19tZXJnZS5sZW5ndGggPiAwID8gMSA6IDA7XG4gICAgICBidWZmZXIyID0ge1xuICAgICAgICBicmFja2V0czogW10sXG4gICAgICAgIHN0cmluZ09wZW46IGZhbHNlLFxuICAgICAgICBpc1ZhbHVlOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gc2V0RXJyb3IodG9rZW5JRCwgcmVhc29uLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIHRva2VuOiB0b2tlbklELFxuICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgcmVhc29uOiByZWFzb25cbiAgICAgICAgfTtcbiAgICAgICAgYnVmZmVyLnRva2Vuc19tZXJnZVt0b2tlbklEICsgb2Zmc2V0XS50eXBlID0gJ2Vycm9yJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZm9sbG93ZWRCeVN5bWJvbCh0b2tlbklELCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0b2tlbklEID09PSB1bmRlZmluZWQpIGNvbnNvbGUuZXJyb3IoJ3Rva2VuSUQgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBjb25zb2xlLmVycm9yKCdvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgIGlmICh0b2tlbklEID09PSBidWZmZXIudG9rZW5zX21lcmdlLmxlbmd0aCAtIDEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gdG9rZW5JRCArIDE7IGkgPCBidWZmZXIudG9rZW5zX21lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gYnVmZmVyLnRva2Vuc19tZXJnZVtpXTtcblxuICAgICAgICAgIHN3aXRjaCAobmV4dFRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2xpbmVicmVhayc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgY2FzZSAnY29sb24nOlxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pbmRleE9mKG5leHRUb2tlbi5zdHJpbmcpID4gLTEpIHJldHVybiBpO2Vsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZvbGxvd3NTeW1ib2wodG9rZW5JRCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodG9rZW5JRCA9PT0gdW5kZWZpbmVkKSBjb25zb2xlLmVycm9yKCd0b2tlbklEIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgY29uc29sZS5lcnJvcignb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICBpZiAodG9rZW5JRCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSB0b2tlbklEIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c1Rva2VuID0gYnVmZmVyLnRva2Vuc19tZXJnZVtpXTtcblxuICAgICAgICAgIHN3aXRjaCAocHJldmlvdXNUb2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdsaW5lYnJlYWsnOlxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbG9uJzpcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZXhPZihwcmV2aW91c1Rva2VuLnN0cmluZykgPiAtMSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0eXBlRm9sbG93ZWQodG9rZW5JRCkge1xuICAgICAgICBpZiAodG9rZW5JRCA9PT0gdW5kZWZpbmVkKSBjb25zb2xlLmVycm9yKCd0b2tlbklEIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgaWYgKHRva2VuSUQgPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gdG9rZW5JRCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV07XG5cbiAgICAgICAgICBzd2l0Y2ggKHByZXZpb3VzVG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnbGluZWJyZWFrJzpcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1Rva2VuLnR5cGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGJyYWNrZXRMaXN0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLnRva2Vuc19tZXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXJyb3IpIGJyZWFrO1xuICAgICAgICBsZXQgdG9rZW4gPSBidWZmZXIudG9rZW5zX21lcmdlW2ldLFxuICAgICAgICAgICAgc3RyaW5nID0gdG9rZW4uc3RyaW5nLFxuICAgICAgICAgICAgdHlwZSA9IHRva2VuLnR5cGUsXG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbGluZWJyZWFrJzpcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHN3aXRjaCAoc3RyaW5nKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZvbGxvd3NTeW1ib2woaSwgWyd9JywgJ10nXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRva2VuU2VxdWVuY2UucHJvaGliaXRlZCwge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiBidWZmZXIudG9rZW5zX21lcmdlW2ZvdW5kXS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZFRva2VuOiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgPT09ICdbJyAmJiBpID4gMCkgaWYgKCFmb2xsb3dzU3ltYm9sKGksIFsnOicsICdbJywgJywnXSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRva2VuU2VxdWVuY2UucGVybWl0dGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VG9rZW46IFwiW1wiLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogW1wiOlwiLCBcIltcIiwgXCIsXCJdXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gJ3snKSBpZiAoZm9sbG93c1N5bWJvbChpLCBbJ3snXSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLmRvdWJsZSwge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbjogXCJ7XCJcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIyLmJyYWNrZXRzLnB1c2goc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBidWZmZXIyLmlzVmFsdWUgPSBidWZmZXIyLmJyYWNrZXRzW2J1ZmZlcjIuYnJhY2tldHMubGVuZ3RoIC0gMV0gPT09ICdbJztcbiAgICAgICAgICAgICAgICBicmFja2V0TGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gJ30nKSBpZiAoYnVmZmVyMi5icmFja2V0c1tidWZmZXIyLmJyYWNrZXRzLmxlbmd0aCAtIDFdICE9PSAneycpIHtcbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuYnJhY2UuY3VybHkubWlzc2luZ09wZW4pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nID09PSAnfScpIGlmIChmb2xsb3dzU3ltYm9sKGksIFsnLCddKSkge1xuICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udG9rZW5TZXF1ZW5jZS5wcm9oaWJpdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VG9rZW46IFwiLFwiLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogXCJ9XCJcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nID09PSAnXScpIGlmIChidWZmZXIyLmJyYWNrZXRzW2J1ZmZlcjIuYnJhY2tldHMubGVuZ3RoIC0gMV0gIT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5icmFjZS5zcXVhcmUubWlzc2luZ09wZW4pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nID09PSAnXScpIGlmIChmb2xsb3dzU3ltYm9sKGksIFsnOiddKSkge1xuICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udG9rZW5TZXF1ZW5jZS5wcm9oaWJpdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VG9rZW46IFwiOlwiLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogXCJdXCJcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIyLmJyYWNrZXRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IGJ1ZmZlcjIuYnJhY2tldHNbYnVmZmVyMi5icmFja2V0cy5sZW5ndGggLSAxXSA9PT0gJ1snO1xuICAgICAgICAgICAgICAgIGJyYWNrZXRMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm9sbG93c1N5bWJvbChpLCBbJ3snXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb2xsb3dlZEJ5U3ltYm9sKGksIFsnfSddKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmJyYWNlLmN1cmx5LmNhbm5vdFdyYXAsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogXCIsXCJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udG9rZW5TZXF1ZW5jZS5wcm9oaWJpdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VG9rZW46IFwie1wiLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogXCIsXCJcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChmb2xsb3dlZEJ5U3ltYm9sKGksIFsnfScsICcsJywgJ10nXSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUubm9UcmFpbGluZ09yTGVhZGluZ0NvbW1hKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3VuZCA9IHR5cGVGb2xsb3dlZChpKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdjb2xvbic6XG4gICAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRlcm1TZXF1ZW5jZS5wcm9oaWJpdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZmlyc3RUZXJtOiBmb3VuZCA9PT0gJ2tleScgPyBsb2NhbGUudHlwZXMua2V5IDogbG9jYWxlLnN5bWJvbHMuY29sb24sXG4gICAgICAgICAgICAgICAgICAgICAgc2Vjb25kVGVybTogbG9jYWxlLnN5bWJvbHMuY29tbWFcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGxvd3NTeW1ib2woaSwgWyd7J10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udG9rZW5TZXF1ZW5jZS5wcm9oaWJpdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiBcIntcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFRva2VuOiBcIixcIlxuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBidWZmZXIyLmlzVmFsdWUgPSBidWZmZXIyLmJyYWNrZXRzW2J1ZmZlcjIuYnJhY2tldHMubGVuZ3RoIC0gMV0gPT09ICdbJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmZXIuanNvbiArPSBzdHJpbmc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NvbG9uJzpcbiAgICAgICAgICAgIGZvdW5kID0gZm9sbG93c1N5bWJvbChpLCBbJ1snXSk7XG5cbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiBmb2xsb3dlZEJ5U3ltYm9sKGksIFsnXSddKSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmJyYWNlLnNxdWFyZS5jYW5ub3RXcmFwLCB7XG4gICAgICAgICAgICAgICAgdG9rZW46IFwiOlwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi50b2tlblNlcXVlbmNlLnByb2hpYml0ZWQsIHtcbiAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiBcIltcIixcbiAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogXCI6XCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVGb2xsb3dlZChpKSAhPT0gJ2tleScpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udGVybVNlcXVlbmNlLnBlcm1pdHRlZCwge1xuICAgICAgICAgICAgICAgIGZpcnN0VGVybTogbG9jYWxlLnN5bWJvbHMuY29sb24sXG4gICAgICAgICAgICAgICAgc2Vjb25kVGVybTogbG9jYWxlLnR5cGVzLmtleVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9sbG93ZWRCeVN5bWJvbChpLCBbJ30nLCAnXSddKSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi50ZXJtU2VxdWVuY2UucGVybWl0dGVkLCB7XG4gICAgICAgICAgICAgICAgZmlyc3RUZXJtOiBsb2NhbGUuc3ltYm9scy5jb2xvbixcbiAgICAgICAgICAgICAgICBzZWNvbmRUZXJtOiBsb2NhbGUudHlwZXMudmFsdWVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyMi5pc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJ1ZmZlci5qc29uICs9IHN0cmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAna2V5JzpcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgbGV0IGZpcnN0Q2hhciA9IHN0cmluZy5jaGFyQXQoMCksXG4gICAgICAgICAgICAgICAgbGFzdENoYXIgPSBzdHJpbmcuY2hhckF0KHN0cmluZy5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICBxdW90ZV9wcmltYXJ5ID0gcXVvdGVzLmluZGV4T2YoZmlyc3RDaGFyKTtcbiAgICAgICAgICAgIGlmIChxdW90ZXMuaW5kZXhPZihmaXJzdENoYXIpID09PSAtMSkgaWYgKHF1b3Rlcy5pbmRleE9mKGxhc3RDaGFyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5zdHJpbmcubWlzc2luZ09wZW4sIHtcbiAgICAgICAgICAgICAgICBxdW90ZTogZmlyc3RDaGFyXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVvdGVzLmluZGV4T2YobGFzdENoYXIpID09PSAtMSkgaWYgKHF1b3Rlcy5pbmRleE9mKGZpcnN0Q2hhcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuc3RyaW5nLm1pc3NpbmdDbG9zZSwge1xuICAgICAgICAgICAgICAgIHF1b3RlOiBmaXJzdENoYXJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdW90ZXMuaW5kZXhPZihmaXJzdENoYXIpID4gLTEpIGlmIChmaXJzdENoYXIgIT09IGxhc3RDaGFyKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuc3RyaW5nLm1pc3NpbmdDbG9zZSwge1xuICAgICAgICAgICAgICAgIHF1b3RlOiBmaXJzdENoYXJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkgaWYgKHF1b3Rlcy5pbmRleE9mKGZpcnN0Q2hhcikgPT09IC0xICYmIHF1b3Rlcy5pbmRleE9mKGxhc3RDaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5zdHJpbmcubXVzdEJlV3JhcHBlZEJ5UXVvdGVzKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdrZXknID09PSB0eXBlKSBpZiAoZm9sbG93ZWRCeVN5bWJvbChpLCBbJ30nLCAnXSddKSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi50ZXJtU2VxdWVuY2UucGVybWl0dGVkLCB7XG4gICAgICAgICAgICAgICAgZmlyc3RUZXJtOiBsb2NhbGUudHlwZXMua2V5LFxuICAgICAgICAgICAgICAgIHNlY29uZFRlcm06IGxvY2FsZS5zeW1ib2xzLmNvbG9uXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdW90ZXMuaW5kZXhPZihmaXJzdENoYXIpID09PSAtMSAmJiBxdW90ZXMuaW5kZXhPZihsYXN0Q2hhcikgPT09IC0xKSBmb3IgKHZhciBoID0gMDsgaCA8IHN0cmluZy5sZW5ndGg7IGgrKykge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIGJyZWFrO1xuICAgICAgICAgICAgICBjb25zdCBjID0gc3RyaW5nLmNoYXJBdChoKTtcblxuICAgICAgICAgICAgICBpZiAoYWxwaGFudW1lcmljLmluZGV4T2YoYykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5zdHJpbmcubm9uQWxwaGFudW1lcmljLCB7XG4gICAgICAgICAgICAgICAgICB0b2tlbjogY1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gXCInXCIpIHN0cmluZyA9ICdcIicgKyBzdHJpbmcuc2xpY2UoMSwgLTEpICsgJ1wiJztlbHNlIGlmIChmaXJzdENoYXIgIT09ICdcIicpIHN0cmluZyA9ICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgICAgICAgICAgaWYgKCdrZXknID09PSB0eXBlKSBpZiAoJ2tleScgPT09IHR5cGVGb2xsb3dlZChpKSkge1xuICAgICAgICAgICAgICBpZiAoaSA+IDApIGlmICghaXNOYU4oYnVmZmVyLnRva2Vuc19tZXJnZVtpIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnRva2Vuc19tZXJnZVtpIC0gMV0gKz0gYnVmZmVyLnRva2Vuc19tZXJnZVtpXTtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmtleS5udW1iZXJBbmRMZXR0ZXJNaXNzaW5nUXVvdGVzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5rZXkuc3BhY2VNaXNzaW5nUXVvdGVzKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdrZXknID09PSB0eXBlKSBpZiAoIWZvbGxvd3NTeW1ib2woaSwgWyd7JywgJywnXSkpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udG9rZW5TZXF1ZW5jZS5wZXJtaXR0ZWQsIHtcbiAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiB0eXBlLFxuICAgICAgICAgICAgICAgIHNlY29uZFRva2VuOiBbXCJ7XCIsIFwiLFwiXVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlKSBpZiAoIWZvbGxvd3NTeW1ib2woaSwgWydbJywgJzonLCAnLCddKSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi50b2tlblNlcXVlbmNlLnBlcm1pdHRlZCwge1xuICAgICAgICAgICAgICAgIGZpcnN0VG9rZW46IHR5cGUsXG4gICAgICAgICAgICAgICAgc2Vjb25kVG9rZW46IFtcIltcIiwgXCI6XCIsIFwiLFwiXVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdrZXknID09PSB0eXBlKSBpZiAoYnVmZmVyMi5pc1ZhbHVlKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuc3RyaW5nLnVuZXhwZWN0ZWRLZXkpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGUpIGlmICghYnVmZmVyMi5pc1ZhbHVlKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUua2V5LnVuZXhwZWN0ZWRTdHJpbmcpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuanNvbiArPSBzdHJpbmc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgY2FzZSAncHJpbWl0aXZlJzpcbiAgICAgICAgICAgIGlmIChmb2xsb3dzU3ltYm9sKGksIFsneyddKSkge1xuICAgICAgICAgICAgICBidWZmZXIudG9rZW5zX21lcmdlW2ldLnR5cGUgPSAna2V5JztcbiAgICAgICAgICAgICAgdHlwZSA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV0udHlwZTtcbiAgICAgICAgICAgICAgc3RyaW5nID0gJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVGb2xsb3dlZChpKSA9PT0gJ2tleScpIHtcbiAgICAgICAgICAgICAgYnVmZmVyLnRva2Vuc19tZXJnZVtpXS50eXBlID0gJ2tleSc7XG4gICAgICAgICAgICAgIHR5cGUgPSBidWZmZXIudG9rZW5zX21lcmdlW2ldLnR5cGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFmb2xsb3dzU3ltYm9sKGksIFsnWycsICc6JywgJywnXSkpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udG9rZW5TZXF1ZW5jZS5wZXJtaXR0ZWQsIHtcbiAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiB0eXBlLFxuICAgICAgICAgICAgICAgIHNlY29uZFRva2VuOiBbXCJbXCIsIFwiOlwiLCBcIixcIl1cbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdrZXknKSBpZiAoIWJ1ZmZlcjIuaXNWYWx1ZSkge1xuICAgICAgICAgICAgICBidWZmZXIudG9rZW5zX21lcmdlW2ldLnR5cGUgPSAna2V5JztcbiAgICAgICAgICAgICAgdHlwZSA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV0udHlwZTtcbiAgICAgICAgICAgICAgc3RyaW5nID0gJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3ByaW1pdGl2ZScpIGlmIChzdHJpbmcgPT09ICd1bmRlZmluZWQnKSBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi51c2VJbnN0ZWFkLCB7XG4gICAgICAgICAgICAgIGJhZFRva2VuOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICBnb29kVG9rZW46IFwibnVsbFwiXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBidWZmZXIuanNvbiArPSBzdHJpbmc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgbm9Fc2NhcGVkU2luZ2xlUXVvdGUgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuanNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY3VycmVudCA9IGJ1ZmZlci5qc29uLmNoYXJBdChpKSxcbiAgICAgICAgICAgIG5leHQgPSAnJztcblxuICAgICAgICBpZiAoaSArIDEgPCBidWZmZXIuanNvbi5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLmpzb24uY2hhckF0KGkgKyAxKTtcblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSAnXFxcXCcgJiYgbmV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIG5vRXNjYXBlZFNpbmdsZVF1b3RlICs9IG5leHQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub0VzY2FwZWRTaW5nbGVRdW90ZSArPSBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgICBidWZmZXIuanNvbiA9IG5vRXNjYXBlZFNpbmdsZVF1b3RlO1xuXG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSBNYXRoLmNlaWwoYnJhY2tldExpc3QubGVuZ3RoIC8gMik7XG4gICAgICAgIGxldCByb3VuZCA9IDAsXG4gICAgICAgICAgICBkZWx0YSA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVBhaXIoaW5kZXgpIHtcbiAgICAgICAgICBicmFja2V0TGlzdC5zcGxpY2UoaW5kZXggKyAxLCAxKTtcbiAgICAgICAgICBicmFja2V0TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGlmICghZGVsdGEpIGRlbHRhID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChicmFja2V0TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVsdGEgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIHRva2VuQ291bnQgPSAwOyB0b2tlbkNvdW50IDwgYnJhY2tldExpc3QubGVuZ3RoIC0gMTsgdG9rZW5Db3VudCsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gYnJhY2tldExpc3RbdG9rZW5Db3VudF0uc3RyaW5nICsgYnJhY2tldExpc3RbdG9rZW5Db3VudCArIDFdLnN0cmluZztcbiAgICAgICAgICAgIGlmIChbJ1tdJywgJ3t9J10uaW5kZXhPZihwYWlyKSA+IC0xKSByZW1vdmVQYWlyKHRva2VuQ291bnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdW5kKys7XG4gICAgICAgICAgaWYgKCFkZWx0YSkgYnJlYWs7XG4gICAgICAgICAgaWYgKHJvdW5kID49IG1heEl0ZXJhdGlvbnMpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJyYWNrZXRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBfdG9rZW5TdHJpbmcgPSBicmFja2V0TGlzdFswXS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgX3Rva2VuUG9zaXRpb24gPSBicmFja2V0TGlzdFswXS5pLFxuICAgICAgICAgICAgICAgIF9jbG9zaW5nQnJhY2tldFR5cGUgPSBfdG9rZW5TdHJpbmcgPT09ICdbJyA/ICddJyA6ICd9JztcblxuICAgICAgICAgIGxpbmUgPSBicmFja2V0TGlzdFswXS5saW5lO1xuICAgICAgICAgIHNldEVycm9yKF90b2tlblBvc2l0aW9uLCBmb3JtYXQobG9jYWxlLmJyYWNlW19jbG9zaW5nQnJhY2tldFR5cGUgPT09ICddJyA/ICdzcXVhcmUnIDogJ2N1cmx5J10ubWlzc2luZ0Nsb3NlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFlcnJvcikgaWYgKFt1bmRlZmluZWQsICcnXS5pbmRleE9mKGJ1ZmZlci5qc29uKSA9PT0gLTEpIHRyeSB7XG4gICAgICAgIGJ1ZmZlci5qc09iamVjdCA9IEpTT04ucGFyc2UoYnVmZmVyLmpzb24pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICBzdWJzTWFyayA9IGVycm9yTWVzc2FnZS5pbmRleE9mKCdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoc3Vic01hcmsgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHBhcnNpbmcgZmFpbGVkJyk7XG4gICAgICAgIGNvbnN0IGVyclBvc2l0aW9uU3RyID0gZXJyb3JNZXNzYWdlLnN1YnN0cmluZyhzdWJzTWFyayArIDksIGVycm9yTWVzc2FnZS5sZW5ndGgpLFxuICAgICAgICAgICAgICBlcnJQb3NpdGlvbiA9IHBhcnNlSW50KGVyclBvc2l0aW9uU3RyKTtcbiAgICAgICAgbGV0IGNoYXJUb3RhbCA9IDAsXG4gICAgICAgICAgICB0b2tlbkluZGV4ID0gMCxcbiAgICAgICAgICAgIHRva2VuID0gZmFsc2UsXG4gICAgICAgICAgICBfbGluZSA9IDEsXG4gICAgICAgICAgICBleGl0V2hpbGUgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSAoY2hhclRvdGFsIDwgZXJyUG9zaXRpb24gJiYgIWV4aXRXaGlsZSkge1xuICAgICAgICAgIHRva2VuID0gYnVmZmVyLnRva2Vuc19tZXJnZVt0b2tlbkluZGV4XTtcbiAgICAgICAgICBpZiAoJ2xpbmVicmVhaycgPT09IHRva2VuLnR5cGUpIF9saW5lKys7XG4gICAgICAgICAgaWYgKFsnc3BhY2UnLCAnbGluZWJyZWFrJ10uaW5kZXhPZih0b2tlbi50eXBlKSA9PT0gLTEpIGNoYXJUb3RhbCArPSB0b2tlbi5zdHJpbmcubGVuZ3RoO1xuICAgICAgICAgIGlmIChjaGFyVG90YWwgPj0gZXJyUG9zaXRpb24pIGJyZWFrO1xuICAgICAgICAgIHRva2VuSW5kZXgrKztcbiAgICAgICAgICBpZiAoIWJ1ZmZlci50b2tlbnNfbWVyZ2VbdG9rZW5JbmRleCArIDFdKSBleGl0V2hpbGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZSA9IF9saW5lO1xuICAgICAgICBsZXQgYmFja3NsYXNoQ291bnQgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW4uc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHRva2VuLnN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKGNoYXIgPT09ICdcXFxcJykgYmFja3NsYXNoQ291bnQgPSBiYWNrc2xhc2hDb3VudCA+IDAgPyBiYWNrc2xhc2hDb3VudCArIDEgOiAxO2Vsc2Uge1xuICAgICAgICAgICAgaWYgKGJhY2tzbGFzaENvdW50ICUgMiAhPT0gMCB8fCBiYWNrc2xhc2hDb3VudCA9PT0gMCkgaWYgKCdcXCdcImJmbnJ0Jy5pbmRleE9mKGNoYXIpID09PSAtMSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcih0b2tlbkluZGV4LCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi51bmV4cGVjdGVkLCB7XG4gICAgICAgICAgICAgICAgdG9rZW46ICdcXFxcJ1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYWNrc2xhc2hDb3VudCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlcnJvcikgc2V0RXJyb3IodG9rZW5JbmRleCwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udW5leHBlY3RlZCwge1xuICAgICAgICAgIHRva2VuOiB0b2tlbi5zdHJpbmdcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgbGV0IF9saW5lID0gMSxcbiAgICAgICAgICBfZGVwdGggPSAwO1xuXG4gICAgICBmdW5jdGlvbiBuZXdJbmRlbnQoKSB7XG4gICAgICAgIHZhciBzcGFjZSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2RlcHRoICogMjsgaSsrKSBzcGFjZS5wdXNoKCcmbmJzcDsnKTtcblxuICAgICAgICByZXR1cm4gc3BhY2Uuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5ld0xpbmVCcmVhayhieVBhc3MgPSBmYWxzZSkge1xuICAgICAgICBfbGluZSsrO1xuXG4gICAgICAgIGlmIChfZGVwdGggPiAwIHx8IGJ5UGFzcykge1xuICAgICAgICAgIHJldHVybiAnPGJyPic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5ld0xpbmVCcmVha0FuZEluZGVudChieVBhc3MgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3TGluZUJyZWFrKGJ5UGFzcykgKyBuZXdJbmRlbnQoKTtcbiAgICAgIH1cblxuICAgICAgO1xuICAgICAgaWYgKCFlcnJvcikgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIudG9rZW5zX21lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gYnVmZmVyLnRva2Vuc19tZXJnZVtpXSxcbiAgICAgICAgICAgICAgc3RyaW5nID0gdG9rZW4uc3RyaW5nLFxuICAgICAgICAgICAgICB0eXBlID0gdG9rZW4udHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgY2FzZSAnbGluZWJyZWFrJzpcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIGNhc2UgJ3ByaW1pdGl2ZSc6XG4gICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgYnVmZmVyLm1hcmt1cCArPSAoZm9sbG93c1N5bWJvbChpLCBbJywnLCAnWyddKSA/IG5ld0xpbmVCcmVha0FuZEluZGVudCgpIDogJycpICsgbmV3U3BhbihpLCB0b2tlbiwgX2RlcHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAna2V5JzpcbiAgICAgICAgICAgIGJ1ZmZlci5tYXJrdXAgKz0gbmV3TGluZUJyZWFrQW5kSW5kZW50KCkgKyBuZXdTcGFuKGksIHRva2VuLCBfZGVwdGgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjb2xvbic6XG4gICAgICAgICAgICBidWZmZXIubWFya3VwICs9IG5ld1NwYW4oaSwgdG9rZW4sIF9kZXB0aCkgKyAnJm5ic3A7JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHN3aXRjaCAoc3RyaW5nKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICBidWZmZXIubWFya3VwICs9ICghZm9sbG93c1N5bWJvbChpLCBbJzonXSkgPyBuZXdMaW5lQnJlYWtBbmRJbmRlbnQoKSA6ICcnKSArIG5ld1NwYW4oaSwgdG9rZW4sIF9kZXB0aCk7XG4gICAgICAgICAgICAgICAgX2RlcHRoKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgICAgIF9kZXB0aC0tO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNsYXN0VG9rZW4gPSBpID09PSBidWZmZXIudG9rZW5zX21lcmdlLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgX2FkanVzdG1lbnQgPSBpID4gMCA/IFsnWycsICd7J10uaW5kZXhPZihidWZmZXIudG9rZW5zX21lcmdlW2kgLSAxXS5zdHJpbmcpID4gLTEgPyAnJyA6IG5ld0xpbmVCcmVha0FuZEluZGVudChpc2xhc3RUb2tlbikgOiAnJztcblxuICAgICAgICAgICAgICAgIGJ1ZmZlci5tYXJrdXAgKz0gX2FkanVzdG1lbnQgKyBuZXdTcGFuKGksIHRva2VuLCBfZGVwdGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgICAgIGJ1ZmZlci5tYXJrdXAgKz0gbmV3U3BhbihpLCB0b2tlbiwgX2RlcHRoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGxldCBfbGluZV9mYWxsYmFjayA9IDE7XG5cbiAgICAgICAgZnVuY3Rpb24gY291bnRDYXJyaWdlUmV0dXJuKHN0cmluZykge1xuICAgICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFsnXFxuJywgJ1xcciddLmluZGV4T2Yoc3RyaW5nW2ldKSA+IC0xKSBjb3VudCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9saW5lID0gMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci50b2tlbnNfbWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV0sXG4gICAgICAgICAgICAgICAgdHlwZSA9IHRva2VuLnR5cGUsXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gdG9rZW4uc3RyaW5nO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnbGluZWJyZWFrJykgX2xpbmUrKztcbiAgICAgICAgICBidWZmZXIubWFya3VwICs9IG5ld1NwYW4oaSwgdG9rZW4sIF9kZXB0aCk7XG4gICAgICAgICAgX2xpbmVfZmFsbGJhY2sgKz0gY291bnRDYXJyaWdlUmV0dXJuKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBfbGluZSsrO1xuICAgICAgICBfbGluZV9mYWxsYmFjaysrO1xuICAgICAgICBpZiAoX2xpbmUgPCBfbGluZV9mYWxsYmFjaykgX2xpbmUgPSBfbGluZV9mYWxsYmFjaztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIudG9rZW5zX21lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV07XG4gICAgICAgIGJ1ZmZlci5pbmRlbnRlZCArPSB0b2tlbi5zdHJpbmc7XG4gICAgICAgIGlmIChbJ3NwYWNlJywgJ2xpbmVicmVhayddLmluZGV4T2YodG9rZW4udHlwZSkgPT09IC0xKSBidWZmZXIudG9rZW5zX3BsYWluVGV4dCArPSB0b2tlbi5zdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYge30udG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdtb2RpZnlFcnJvclRleHQnIGluIHRoaXMucHJvcHMpIGlmIChpc0Z1bmN0aW9uKHRoaXMucHJvcHMubW9kaWZ5RXJyb3JUZXh0KSkgZXJyb3IucmVhc29uID0gdGhpcy5wcm9wcy5tb2RpZnlFcnJvclRleHQoZXJyb3IucmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5zOiBidWZmZXIudG9rZW5zX21lcmdlLFxuICAgICAgICBub1NwYWNlczogYnVmZmVyLnRva2Vuc19wbGFpblRleHQsXG4gICAgICAgIGluZGVudGVkOiBidWZmZXIuaW5kZW50ZWQsXG4gICAgICAgIGpzb246IGJ1ZmZlci5qc29uLFxuICAgICAgICBqc09iamVjdDogYnVmZmVyLmpzT2JqZWN0LFxuICAgICAgICBtYXJrdXA6IGJ1ZmZlci5tYXJrdXAsXG4gICAgICAgIGxpbmVzOiBfbGluZSxcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH1cblxuICAgIDtcbiAgICAvKipcclxuICAgICAqICAgICBKUyBPQkpFQ1RTIHx8IFBMQUNFSE9MREVSXHJcbiAgICAgKi9cblxuICAgIGlmICghKCdub2RlVHlwZScgaW4gc29tZXRoaW5nKSkge1xuICAgICAgbGV0IGJ1ZmZlciA9IHtcbiAgICAgICAgaW5wdXRUZXh0OiBKU09OLnN0cmluZ2lmeShzb21ldGhpbmcpLFxuICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgY3VycmVudENoYXI6ICcnLFxuICAgICAgICB0b2tlblByaW1hcnk6ICcnLFxuICAgICAgICB0b2tlblNlY29uZGFyeTogJycsXG4gICAgICAgIGJyYWNrZXRzOiBbXSxcbiAgICAgICAgaXNWYWx1ZTogZmFsc2UsXG4gICAgICAgIHN0cmluZ09wZW46IGZhbHNlLFxuICAgICAgICBzdHJpbmdTdGFydDogMCxcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gZXNjYXBlX2NoYXJhY3RlcigpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5jdXJyZW50Q2hhciAhPT0gJ1xcXFwnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJ1ZmZlci5pbnB1dFRleHQgPSBkZWxldGVDaGFyQXQoYnVmZmVyLmlucHV0VGV4dCwgYnVmZmVyLnBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZUNoYXJBdChzdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgcG9zaXRpb24pICsgc3RyaW5nLnNsaWNlKHBvc2l0aW9uICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRldGVybWluZV9zdHJpbmcoKSB7XG4gICAgICAgIGlmICgnXFwnXCInLmluZGV4T2YoYnVmZmVyLmN1cnJlbnRDaGFyKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoIWJ1ZmZlci5zdHJpbmdPcGVuKSB7XG4gICAgICAgICAgYWRkX3Rva2VuU2Vjb25kYXJ5KCk7XG4gICAgICAgICAgYnVmZmVyLnN0cmluZ1N0YXJ0ID0gYnVmZmVyLnBvc2l0aW9uO1xuICAgICAgICAgIGJ1ZmZlci5zdHJpbmdPcGVuID0gYnVmZmVyLmN1cnJlbnRDaGFyO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1ZmZlci5zdHJpbmdPcGVuID09PSBidWZmZXIuY3VycmVudENoYXIpIHtcbiAgICAgICAgICBhZGRfdG9rZW5TZWNvbmRhcnkoKTtcbiAgICAgICAgICBjb25zdCBzdHJpbmdUb2tlbiA9IGJ1ZmZlci5pbnB1dFRleHQuc3Vic3RyaW5nKGJ1ZmZlci5zdHJpbmdTdGFydCwgYnVmZmVyLnBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgYWRkX3Rva2VuUHJpbWFyeShzdHJpbmdUb2tlbik7XG4gICAgICAgICAgYnVmZmVyLnN0cmluZ09wZW4gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5lX3ZhbHVlKCkge1xuICAgICAgICBpZiAoJzose31bXScuaW5kZXhPZihidWZmZXIuY3VycmVudENoYXIpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYnVmZmVyLnN0cmluZ09wZW4pIHJldHVybiBmYWxzZTtcbiAgICAgICAgYWRkX3Rva2VuU2Vjb25kYXJ5KCk7XG4gICAgICAgIGFkZF90b2tlblByaW1hcnkoYnVmZmVyLmN1cnJlbnRDaGFyKTtcblxuICAgICAgICBzd2l0Y2ggKGJ1ZmZlci5jdXJyZW50Q2hhcikge1xuICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgYnVmZmVyLmlzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgYnVmZmVyLmJyYWNrZXRzLnB1c2goYnVmZmVyLmN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICBidWZmZXIuYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmZXIuY3VycmVudENoYXIgIT09ICc6JykgYnVmZmVyLmlzVmFsdWUgPSBidWZmZXIuYnJhY2tldHNbYnVmZmVyLmJyYWNrZXRzLmxlbmd0aCAtIDFdID09PSAnWyc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRfdG9rZW5TZWNvbmRhcnkoKSB7XG4gICAgICAgIGlmIChidWZmZXIudG9rZW5TZWNvbmRhcnkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJ1ZmZlci50b2tlbnMucHVzaChidWZmZXIudG9rZW5TZWNvbmRhcnkpO1xuICAgICAgICBidWZmZXIudG9rZW5TZWNvbmRhcnkgPSAnJztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZF90b2tlblByaW1hcnkodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBidWZmZXIudG9rZW5zLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuaW5wdXRUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlci5wb3NpdGlvbiA9IGk7XG4gICAgICAgIGJ1ZmZlci5jdXJyZW50Q2hhciA9IGJ1ZmZlci5pbnB1dFRleHQuY2hhckF0KGJ1ZmZlci5wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGEgPSBkZXRlcm1pbmVfdmFsdWUoKSxcbiAgICAgICAgICAgICAgYiA9IGRldGVybWluZV9zdHJpbmcoKSxcbiAgICAgICAgICAgICAgYyA9IGVzY2FwZV9jaGFyYWN0ZXIoKTtcbiAgICAgICAgaWYgKCFhICYmICFiICYmICFjKSBpZiAoIWJ1ZmZlci5zdHJpbmdPcGVuKSBidWZmZXIudG9rZW5TZWNvbmRhcnkgKz0gYnVmZmVyLmN1cnJlbnRDaGFyO1xuICAgICAgfVxuXG4gICAgICBsZXQgYnVmZmVyMiA9IHtcbiAgICAgICAgYnJhY2tldHM6IFtdLFxuICAgICAgICBpc1ZhbHVlOiBmYWxzZSxcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfTtcbiAgICAgIGJ1ZmZlcjIudG9rZW5zID0gYnVmZmVyLnRva2Vucy5tYXAodG9rZW4gPT4ge1xuICAgICAgICBsZXQgdHlwZSA9ICcnLFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHR5cGUgPSAnc3ltYm9sJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IGJ1ZmZlcjIuYnJhY2tldHNbYnVmZmVyMi5icmFja2V0cy5sZW5ndGggLSAxXSA9PT0gJ1snO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIHR5cGUgPSAnc3ltYm9sJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgdHlwZSA9ICdzeW1ib2wnO1xuICAgICAgICAgICAgc3RyaW5nID0gdG9rZW47XG4gICAgICAgICAgICB2YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgYnVmZmVyMi5icmFja2V0cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IGJ1ZmZlcjIuYnJhY2tldHNbYnVmZmVyMi5icmFja2V0cy5sZW5ndGggLSAxXSA9PT0gJ1snO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHR5cGUgPSAnc3ltYm9sJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGJ1ZmZlcjIuYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICBidWZmZXIyLmlzVmFsdWUgPSBidWZmZXIyLmJyYWNrZXRzW2J1ZmZlcjIuYnJhY2tldHMubGVuZ3RoIC0gMV0gPT09ICdbJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHR5cGUgPSAncHJpbWl0aXZlJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgdHlwZSA9ICdwcmltaXRpdmUnO1xuICAgICAgICAgICAgc3RyaW5nID0gdG9rZW47XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgIHR5cGUgPSAncHJpbWl0aXZlJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgICAgICB0eXBlID0gJ3ByaW1pdGl2ZSc7XG4gICAgICAgICAgICBzdHJpbmcgPSB0b2tlbjtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnN0IEMgPSB0b2tlbi5jaGFyQXQoMCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0cmlwUXVvdGVzRnJvbUtleSh0ZXh0KSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgIGlmIChbJ1wiXCInLCBcIicnXCJdLmluZGV4T2YodGV4dCkgPiAtMSkgcmV0dXJuIFwiJydcIjtcbiAgICAgICAgICAgICAgbGV0IHdyYXBwZWRJblF1b3RlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFt0ZXh0LmNoYXJBdCgwKSwgdGV4dC5jaGFyQXQodGV4dC5sZW5ndGggLSAxKV0uaW5kZXhPZihbJ1wiJywgXCInXCJdW2ldKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3cmFwcGVkSW5RdW90ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHdyYXBwZWRJblF1b3RlcyAmJiB0ZXh0Lmxlbmd0aCA+PSAyKSB0ZXh0ID0gdGV4dC5zbGljZSgxLCAtMSk7XG5cbiAgICAgICAgICAgICAgY29uc3Qgbm9uQWxwaGFOdW1lcmljID0gdGV4dC5yZXBsYWNlKC9cXHcvZywgJycpLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYU51bWVyaWMgPSB0ZXh0LnJlcGxhY2UoL1xcVysvZywgJycpLFxuICAgICAgICAgICAgICAgICAgICBtYXlSZW1vdmVRdW90ZXMgPSAoKG5vbkFscGhhTnVtZXJpYywgdGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBudW1iZXJBbmRMZXR0ZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIGlmIChpc05hTih0ZXh0LmNoYXJBdChpKSkpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odGV4dC5jaGFyQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlckFuZExldHRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAhKG5vbkFscGhhTnVtZXJpYy5sZW5ndGggPiAwIHx8IG51bWJlckFuZExldHRlcik7XG4gICAgICAgICAgICAgIH0pKG5vbkFscGhhTnVtZXJpYywgdGV4dCksXG4gICAgICAgICAgICAgICAgICAgIGhhc1F1b3RlcyA9IChzdHJpbmcgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoW1wiJ1wiLCAnXCInXS5pbmRleE9mKHN0cmluZy5jaGFyQXQoaSkpID4gLTEpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSkobm9uQWxwaGFOdW1lcmljKTtcblxuICAgICAgICAgICAgICBpZiAoaGFzUXVvdGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1RleHQgPSAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyTGlzdCA9IHRleHQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNoYXJMaXN0Lmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IGNoYXIgPSBjaGFyTGlzdFtpaV07XG4gICAgICAgICAgICAgICAgICBpZiAoW1wiJ1wiLCAnXCInXS5pbmRleE9mKGNoYXIpID4gLTEpIGNoYXIgPSAnXFxcXCcgKyBjaGFyO1xuICAgICAgICAgICAgICAgICAgbmV3VGV4dCArPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHQgPSBuZXdUZXh0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFtYXlSZW1vdmVRdW90ZXMpIHJldHVybiBcIidcIiArIHRleHQgKyBcIidcIjtlbHNlIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ1xcJ1wiJy5pbmRleE9mKEMpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcjIuaXNWYWx1ZSkgdHlwZSA9ICdzdHJpbmcnO2Vsc2UgdHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2tleScpIHN0cmluZyA9IHN0cmlwUXVvdGVzRnJvbUtleSh0b2tlbik7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhckxpc3QyID0gdG9rZW4uc2xpY2UoMSwgLTEpLnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBjaGFyTGlzdDIubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgY2hhciA9IGNoYXJMaXN0MltpaV07XG4gICAgICAgICAgICAgICAgICBpZiAoJ1xcJ1xcXCInLmluZGV4T2YoY2hhcikgPiAtMSkgY2hhciA9ICdcXFxcJyArIGNoYXI7XG4gICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBcIidcIiArIHN0cmluZyArIFwiJ1wiO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHRva2VuKSkge1xuICAgICAgICAgICAgICB0eXBlID0gJ251bWJlcic7XG4gICAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcih0b2tlbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkgaWYgKCFidWZmZXIyLmlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgICBzdHJpbmcgPSB0b2tlbjtcbiAgICAgICAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcgJykgPiAtMSkgc3RyaW5nID0gXCInXCIgKyBzdHJpbmcgKyBcIidcIjtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkZXB0aDogYnVmZmVyMi5icmFja2V0cy5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgbGV0IGNsZWFuID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyMi50b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRva2VuID0gYnVmZmVyMi50b2tlbnNbaV07XG4gICAgICAgIGNsZWFuICs9IHRva2VuLnN0cmluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5kZW50KG51bWJlcikge1xuICAgICAgICB2YXIgc3BhY2UgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlciAqIDI7IGkrKykgc3BhY2UucHVzaCgnICcpO1xuXG4gICAgICAgIHJldHVybiAobnVtYmVyID4gMCA/ICdcXG4nIDogJycpICsgc3BhY2Uuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIDtcbiAgICAgIGxldCBpbmRlbnRhdGlvbiA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcjIudG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IGJ1ZmZlcjIudG9rZW5zW2ldO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4uc3RyaW5nKSB7XG4gICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSBpIDwgYnVmZmVyMi50b2tlbnMubGVuZ3RoIC0gMSAtIDEgPyBidWZmZXIyLnRva2Vuc1tpICsgMV0gOiAnJztcbiAgICAgICAgICAgIGlmICgnfV0nLmluZGV4T2YobmV4dFRva2VuLnN0cmluZykgPT09IC0xKSBpbmRlbnRhdGlvbiArPSB0b2tlbi5zdHJpbmcgKyBpbmRlbnQodG9rZW4uZGVwdGgpO2Vsc2UgaW5kZW50YXRpb24gKz0gdG9rZW4uc3RyaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNvbnN0IHByZXZUb2tlbiA9IGkgPiAwID8gYnVmZmVyMi50b2tlbnNbaSAtIDFdIDogJyc7XG4gICAgICAgICAgICBpZiAoJ1t7Jy5pbmRleE9mKHByZXZUb2tlbi5zdHJpbmcpID09PSAtMSkgaW5kZW50YXRpb24gKz0gaW5kZW50KHRva2VuLmRlcHRoKSArIHRva2VuLnN0cmluZztlbHNlIGluZGVudGF0aW9uICs9IHRva2VuLnN0cmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB0b2tlbi5zdHJpbmcgKyAnICc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gdG9rZW4uc3RyaW5nICsgaW5kZW50KHRva2VuLmRlcHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHRva2VuLnN0cmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBsaW5lcyA9IDE7XG5cbiAgICAgIGZ1bmN0aW9uIGluZGVudElJKG51bWJlcikge1xuICAgICAgICB2YXIgc3BhY2UgPSBbXTtcbiAgICAgICAgaWYgKG51bWJlciA+IDApIGxpbmVzKys7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXIgKiAyOyBpKyspIHNwYWNlLnB1c2goJyZuYnNwOycpO1xuXG4gICAgICAgIHJldHVybiAobnVtYmVyID4gMCA/ICc8YnI+JyA6ICcnKSArIHNwYWNlLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICA7XG4gICAgICBsZXQgbWFya3VwID0gJyc7XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBidWZmZXIyLnRva2Vucy5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcjIudG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IGJ1ZmZlcjIudG9rZW5zW2ldO1xuICAgICAgICBsZXQgc3BhbiA9IG5ld1NwYW4oaSwgdG9rZW4sIHRva2VuLmRlcHRoKTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnN0cmluZykge1xuICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gaSA8IGJ1ZmZlcjIudG9rZW5zLmxlbmd0aCAtIDEgLSAxID8gYnVmZmVyMi50b2tlbnNbaSArIDFdIDogJyc7XG4gICAgICAgICAgICBpZiAoJ31dJy5pbmRleE9mKG5leHRUb2tlbi5zdHJpbmcpID09PSAtMSkgbWFya3VwICs9IHNwYW4gKyBpbmRlbnRJSSh0b2tlbi5kZXB0aCk7ZWxzZSBtYXJrdXAgKz0gc3BhbjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICBjb25zdCBwcmV2VG9rZW4gPSBpID4gMCA/IGJ1ZmZlcjIudG9rZW5zW2kgLSAxXSA6ICcnO1xuICAgICAgICAgICAgaWYgKCdbeycuaW5kZXhPZihwcmV2VG9rZW4uc3RyaW5nKSA9PT0gLTEpIG1hcmt1cCArPSBpbmRlbnRJSSh0b2tlbi5kZXB0aCkgKyAobGFzdEluZGV4ID09PSBpID8gJzxicj4nIDogJycpICsgc3BhbjtlbHNlIG1hcmt1cCArPSBzcGFuO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIG1hcmt1cCArPSBzcGFuICsgJyAnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIG1hcmt1cCArPSBzcGFuICsgaW5kZW50SUkodG9rZW4uZGVwdGgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWFya3VwICs9IHNwYW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lcyArPSAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5zOiBidWZmZXIyLnRva2VucyxcbiAgICAgICAgbm9TcGFjZXM6IGNsZWFuLFxuICAgICAgICBpbmRlbnRlZDogaW5kZW50YXRpb24sXG4gICAgICAgIGpzb246IEpTT04uc3RyaW5naWZ5KHNvbWV0aGluZyksXG4gICAgICAgIGpzT2JqZWN0OiBzb21ldGhpbmcsXG4gICAgICAgIG1hcmt1cDogbWFya3VwLFxuICAgICAgICBsaW5lczogbGluZXNcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSlNPTklucHV0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/es/index.js\n");

/***/ }),

/***/ "./node_modules/react-json-editor-ajrm/es/locale/en.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/locale/en.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  format: \"{reason} at line {line}\",\n  symbols: {\n    colon: \"colon\",\n    // :\n    comma: \"comma\",\n    // ,  ،  、\n    semicolon: \"semicolon\",\n    // ;\n    slash: \"slash\",\n    // /  relevant for comment syntax support\n    backslash: \"backslash\",\n    // \\  relevant for escaping character\n    brackets: {\n      round: \"round brackets\",\n      // ( )\n      square: \"square brackets\",\n      // [ ]\n      curly: \"curly brackets\",\n      // { }\n      angle: \"angle brackets\" // < >\n\n    },\n    period: \"period\",\n    // . Also known as full point, full stop, or dot\n    quotes: {\n      single: \"single quote\",\n      // '\n      double: \"double quote\",\n      // \"\n      grave: \"grave accent\" // ` used on Javascript ES6 Syntax for String Templates\n\n    },\n    space: \"space\",\n    //       \n    ampersand: \"ampersand\",\n    //\t&\n    asterisk: \"asterisk\",\n    //\t*  relevant for some comment sytanx\n    at: \"at sign\",\n    //\t@  multiple uses in other coding languages including certain data types\n    equals: \"equals sign\",\n    //\t=\n    hash: \"hash\",\n    //\t#\n    percent: \"percent\",\n    //\t%\n    plus: \"plus\",\n    //\t+\n    minus: \"minus\",\n    //\t−\n    dash: \"dash\",\n    //\t−\n    hyphen: \"hyphen\",\n    //\t−\n    tilde: \"tilde\",\n    //\t~\n    underscore: \"underscore\",\n    //\t_\n    bar: \"vertical bar\" //\t|\n\n  },\n  types: {\n    key: \"key\",\n    value: \"value\",\n    number: \"number\",\n    string: \"string\",\n    primitive: \"primitive\",\n    boolean: \"boolean\",\n    character: \"character\",\n    integer: \"integer\",\n    array: \"array\",\n    float: \"float\" //... Reference: https://en.wikipedia.org/wiki/List_of_data_structures\n\n  },\n  invalidToken: {\n    tokenSequence: {\n      prohibited: \"'{firstToken}' token cannot be followed by '{secondToken}' token(s)\",\n      permitted: \"'{firstToken}' token can only be followed by '{secondToken}' token(s)\"\n    },\n    termSequence: {\n      prohibited: \"A {firstTerm} cannot be followed by a {secondTerm}\",\n      permitted: \"A {firstTerm} can only be followed by a {secondTerm}\"\n    },\n    double: \"'{token}' token cannot be followed by another '{token}' token\",\n    useInstead: \"'{badToken}' token is not accepted. Use '{goodToken}' instead\",\n    unexpected: \"Unexpected '{token}' token found\"\n  },\n  brace: {\n    curly: {\n      missingOpen: \"Missing '{' open curly brace\",\n      missingClose: \"Open '{' curly brace is missing closing '}' curly brace\",\n      cannotWrap: \"'{token}' token cannot be wrapped in '{}' curly braces\"\n    },\n    square: {\n      missingOpen: \"Missing '[' open square brace\",\n      missingClose: \"Open '[' square brace is missing closing ']' square brace\",\n      cannotWrap: \"'{token}' token cannot be wrapped in '[]' square braces\"\n    }\n  },\n  string: {\n    missingOpen: \"Missing/invalid opening string '{quote}' token\",\n    missingClose: \"Missing/invalid closing string '{quote}' token\",\n    mustBeWrappedByQuotes: \"Strings must be wrapped by quotes\",\n    nonAlphanumeric: \"Non-alphanumeric token '{token}' is not allowed outside string notation\",\n    unexpectedKey: \"Unexpected key found at string position\"\n  },\n  key: {\n    numberAndLetterMissingQuotes: \"Key beginning with number and containing letters must be wrapped by quotes\",\n    spaceMissingQuotes: \"Key containing space must be wrapped by quotes\",\n    unexpectedString: \"Unexpected string found at key position\"\n  },\n  noTrailingOrLeadingComma: \"Trailing or leading commas in arrays and objects are not permitted\"\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9sb2NhbGUvZW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9sb2NhbGUvZW4uanM/NzJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XG4gIGZvcm1hdDogXCJ7cmVhc29ufSBhdCBsaW5lIHtsaW5lfVwiLFxuICBzeW1ib2xzOiB7XG4gICAgY29sb246IFwiY29sb25cIixcbiAgICAvLyA6XG4gICAgY29tbWE6IFwiY29tbWFcIixcbiAgICAvLyAsICDYjCAg44CBXG4gICAgc2VtaWNvbG9uOiBcInNlbWljb2xvblwiLFxuICAgIC8vIDtcbiAgICBzbGFzaDogXCJzbGFzaFwiLFxuICAgIC8vIC8gIHJlbGV2YW50IGZvciBjb21tZW50IHN5bnRheCBzdXBwb3J0XG4gICAgYmFja3NsYXNoOiBcImJhY2tzbGFzaFwiLFxuICAgIC8vIFxcICByZWxldmFudCBmb3IgZXNjYXBpbmcgY2hhcmFjdGVyXG4gICAgYnJhY2tldHM6IHtcbiAgICAgIHJvdW5kOiBcInJvdW5kIGJyYWNrZXRzXCIsXG4gICAgICAvLyAoIClcbiAgICAgIHNxdWFyZTogXCJzcXVhcmUgYnJhY2tldHNcIixcbiAgICAgIC8vIFsgXVxuICAgICAgY3VybHk6IFwiY3VybHkgYnJhY2tldHNcIixcbiAgICAgIC8vIHsgfVxuICAgICAgYW5nbGU6IFwiYW5nbGUgYnJhY2tldHNcIiAvLyA8ID5cblxuICAgIH0sXG4gICAgcGVyaW9kOiBcInBlcmlvZFwiLFxuICAgIC8vIC4gQWxzbyBrbm93biBhcyBmdWxsIHBvaW50LCBmdWxsIHN0b3AsIG9yIGRvdFxuICAgIHF1b3Rlczoge1xuICAgICAgc2luZ2xlOiBcInNpbmdsZSBxdW90ZVwiLFxuICAgICAgLy8gJ1xuICAgICAgZG91YmxlOiBcImRvdWJsZSBxdW90ZVwiLFxuICAgICAgLy8gXCJcbiAgICAgIGdyYXZlOiBcImdyYXZlIGFjY2VudFwiIC8vIGAgdXNlZCBvbiBKYXZhc2NyaXB0IEVTNiBTeW50YXggZm9yIFN0cmluZyBUZW1wbGF0ZXNcblxuICAgIH0sXG4gICAgc3BhY2U6IFwic3BhY2VcIixcbiAgICAvLyAgIOKAgiAg4oCDXG4gICAgYW1wZXJzYW5kOiBcImFtcGVyc2FuZFwiLFxuICAgIC8vXHQmXG4gICAgYXN0ZXJpc2s6IFwiYXN0ZXJpc2tcIixcbiAgICAvL1x0KiAgcmVsZXZhbnQgZm9yIHNvbWUgY29tbWVudCBzeXRhbnhcbiAgICBhdDogXCJhdCBzaWduXCIsXG4gICAgLy9cdEAgIG11bHRpcGxlIHVzZXMgaW4gb3RoZXIgY29kaW5nIGxhbmd1YWdlcyBpbmNsdWRpbmcgY2VydGFpbiBkYXRhIHR5cGVzXG4gICAgZXF1YWxzOiBcImVxdWFscyBzaWduXCIsXG4gICAgLy9cdD1cbiAgICBoYXNoOiBcImhhc2hcIixcbiAgICAvL1x0I1xuICAgIHBlcmNlbnQ6IFwicGVyY2VudFwiLFxuICAgIC8vXHQlXG4gICAgcGx1czogXCJwbHVzXCIsXG4gICAgLy9cdCtcbiAgICBtaW51czogXCJtaW51c1wiLFxuICAgIC8vXHTiiJJcbiAgICBkYXNoOiBcImRhc2hcIixcbiAgICAvL1x04oiSXG4gICAgaHlwaGVuOiBcImh5cGhlblwiLFxuICAgIC8vXHTiiJJcbiAgICB0aWxkZTogXCJ0aWxkZVwiLFxuICAgIC8vXHR+XG4gICAgdW5kZXJzY29yZTogXCJ1bmRlcnNjb3JlXCIsXG4gICAgLy9cdF9cbiAgICBiYXI6IFwidmVydGljYWwgYmFyXCIgLy9cdHxcblxuICB9LFxuICB0eXBlczoge1xuICAgIGtleTogXCJrZXlcIixcbiAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxuICAgIG51bWJlcjogXCJudW1iZXJcIixcbiAgICBzdHJpbmc6IFwic3RyaW5nXCIsXG4gICAgcHJpbWl0aXZlOiBcInByaW1pdGl2ZVwiLFxuICAgIGJvb2xlYW46IFwiYm9vbGVhblwiLFxuICAgIGNoYXJhY3RlcjogXCJjaGFyYWN0ZXJcIixcbiAgICBpbnRlZ2VyOiBcImludGVnZXJcIixcbiAgICBhcnJheTogXCJhcnJheVwiLFxuICAgIGZsb2F0OiBcImZsb2F0XCIgLy8uLi4gUmVmZXJlbmNlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX2RhdGFfc3RydWN0dXJlc1xuXG4gIH0sXG4gIGludmFsaWRUb2tlbjoge1xuICAgIHRva2VuU2VxdWVuY2U6IHtcbiAgICAgIHByb2hpYml0ZWQ6IFwiJ3tmaXJzdFRva2VufScgdG9rZW4gY2Fubm90IGJlIGZvbGxvd2VkIGJ5ICd7c2Vjb25kVG9rZW59JyB0b2tlbihzKVwiLFxuICAgICAgcGVybWl0dGVkOiBcIid7Zmlyc3RUb2tlbn0nIHRva2VuIGNhbiBvbmx5IGJlIGZvbGxvd2VkIGJ5ICd7c2Vjb25kVG9rZW59JyB0b2tlbihzKVwiXG4gICAgfSxcbiAgICB0ZXJtU2VxdWVuY2U6IHtcbiAgICAgIHByb2hpYml0ZWQ6IFwiQSB7Zmlyc3RUZXJtfSBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgYSB7c2Vjb25kVGVybX1cIixcbiAgICAgIHBlcm1pdHRlZDogXCJBIHtmaXJzdFRlcm19IGNhbiBvbmx5IGJlIGZvbGxvd2VkIGJ5IGEge3NlY29uZFRlcm19XCJcbiAgICB9LFxuICAgIGRvdWJsZTogXCIne3Rva2VufScgdG9rZW4gY2Fubm90IGJlIGZvbGxvd2VkIGJ5IGFub3RoZXIgJ3t0b2tlbn0nIHRva2VuXCIsXG4gICAgdXNlSW5zdGVhZDogXCIne2JhZFRva2VufScgdG9rZW4gaXMgbm90IGFjY2VwdGVkLiBVc2UgJ3tnb29kVG9rZW59JyBpbnN0ZWFkXCIsXG4gICAgdW5leHBlY3RlZDogXCJVbmV4cGVjdGVkICd7dG9rZW59JyB0b2tlbiBmb3VuZFwiXG4gIH0sXG4gIGJyYWNlOiB7XG4gICAgY3VybHk6IHtcbiAgICAgIG1pc3NpbmdPcGVuOiBcIk1pc3NpbmcgJ3snIG9wZW4gY3VybHkgYnJhY2VcIixcbiAgICAgIG1pc3NpbmdDbG9zZTogXCJPcGVuICd7JyBjdXJseSBicmFjZSBpcyBtaXNzaW5nIGNsb3NpbmcgJ30nIGN1cmx5IGJyYWNlXCIsXG4gICAgICBjYW5ub3RXcmFwOiBcIid7dG9rZW59JyB0b2tlbiBjYW5ub3QgYmUgd3JhcHBlZCBpbiAne30nIGN1cmx5IGJyYWNlc1wiXG4gICAgfSxcbiAgICBzcXVhcmU6IHtcbiAgICAgIG1pc3NpbmdPcGVuOiBcIk1pc3NpbmcgJ1snIG9wZW4gc3F1YXJlIGJyYWNlXCIsXG4gICAgICBtaXNzaW5nQ2xvc2U6IFwiT3BlbiAnWycgc3F1YXJlIGJyYWNlIGlzIG1pc3NpbmcgY2xvc2luZyAnXScgc3F1YXJlIGJyYWNlXCIsXG4gICAgICBjYW5ub3RXcmFwOiBcIid7dG9rZW59JyB0b2tlbiBjYW5ub3QgYmUgd3JhcHBlZCBpbiAnW10nIHNxdWFyZSBicmFjZXNcIlxuICAgIH1cbiAgfSxcbiAgc3RyaW5nOiB7XG4gICAgbWlzc2luZ09wZW46IFwiTWlzc2luZy9pbnZhbGlkIG9wZW5pbmcgc3RyaW5nICd7cXVvdGV9JyB0b2tlblwiLFxuICAgIG1pc3NpbmdDbG9zZTogXCJNaXNzaW5nL2ludmFsaWQgY2xvc2luZyBzdHJpbmcgJ3txdW90ZX0nIHRva2VuXCIsXG4gICAgbXVzdEJlV3JhcHBlZEJ5UXVvdGVzOiBcIlN0cmluZ3MgbXVzdCBiZSB3cmFwcGVkIGJ5IHF1b3Rlc1wiLFxuICAgIG5vbkFscGhhbnVtZXJpYzogXCJOb24tYWxwaGFudW1lcmljIHRva2VuICd7dG9rZW59JyBpcyBub3QgYWxsb3dlZCBvdXRzaWRlIHN0cmluZyBub3RhdGlvblwiLFxuICAgIHVuZXhwZWN0ZWRLZXk6IFwiVW5leHBlY3RlZCBrZXkgZm91bmQgYXQgc3RyaW5nIHBvc2l0aW9uXCJcbiAgfSxcbiAga2V5OiB7XG4gICAgbnVtYmVyQW5kTGV0dGVyTWlzc2luZ1F1b3RlczogXCJLZXkgYmVnaW5uaW5nIHdpdGggbnVtYmVyIGFuZCBjb250YWluaW5nIGxldHRlcnMgbXVzdCBiZSB3cmFwcGVkIGJ5IHF1b3Rlc1wiLFxuICAgIHNwYWNlTWlzc2luZ1F1b3RlczogXCJLZXkgY29udGFpbmluZyBzcGFjZSBtdXN0IGJlIHdyYXBwZWQgYnkgcXVvdGVzXCIsXG4gICAgdW5leHBlY3RlZFN0cmluZzogXCJVbmV4cGVjdGVkIHN0cmluZyBmb3VuZCBhdCBrZXkgcG9zaXRpb25cIlxuICB9LFxuICBub1RyYWlsaW5nT3JMZWFkaW5nQ29tbWE6IFwiVHJhaWxpbmcgb3IgbGVhZGluZyBjb21tYXMgaW4gYXJyYXlzIGFuZCBvYmplY3RzIGFyZSBub3QgcGVybWl0dGVkXCJcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/es/locale/en.js\n");

/***/ }),

/***/ "./node_modules/react-json-editor-ajrm/es/locale/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/locale/index.js ***!
  \****************************************************************/
/*! exports provided: format */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return format; });\n// Allows us to pass arrays and numbers instead of just strings to the format function.\nconst stringify = arg => Array.isArray(arg) ? arg.join(\", \") : typeof arg === \"string\" ? arg : \"\" + arg; // Replaces a string with the values of an object. Google \"format unicorn\" on an explanation of how to use.\n\n\nconst format = (str, args) => args ? Object.keys(args).reduce((str, arg) => str.replace(new RegExp(`\\\\{${arg}\\\\}`, 'gi'), stringify(args[arg])), str) : str;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9sb2NhbGUvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9sb2NhbGUvaW5kZXguanM/M2FkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBbGxvd3MgdXMgdG8gcGFzcyBhcnJheXMgYW5kIG51bWJlcnMgaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MgdG8gdGhlIGZvcm1hdCBmdW5jdGlvbi5cbmNvbnN0IHN0cmluZ2lmeSA9IGFyZyA9PiBBcnJheS5pc0FycmF5KGFyZykgPyBhcmcuam9pbihcIiwgXCIpIDogdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIiA/IGFyZyA6IFwiXCIgKyBhcmc7IC8vIFJlcGxhY2VzIGEgc3RyaW5nIHdpdGggdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QuIEdvb2dsZSBcImZvcm1hdCB1bmljb3JuXCIgb24gYW4gZXhwbGFuYXRpb24gb2YgaG93IHRvIHVzZS5cblxuXG5jb25zdCBmb3JtYXQgPSAoc3RyLCBhcmdzKSA9PiBhcmdzID8gT2JqZWN0LmtleXMoYXJncykucmVkdWNlKChzdHIsIGFyZykgPT4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChgXFxcXHske2FyZ31cXFxcfWAsICdnaScpLCBzdHJpbmdpZnkoYXJnc1thcmddKSksIHN0cikgOiBzdHI7XG5cbmV4cG9ydCB7IGZvcm1hdCB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/es/locale/index.js\n");

/***/ }),

/***/ "./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author Andrew Redican <andrew.redican.mejia@gmail.com>\r\n */\n\n/**\r\n * Performs deep search on object tree, removes all properties with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\nfunction deepRemoveAll_Key(identity, keyName, maxDepth) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  let clonedIdentity = deepClone(identity);\n  var paths = locateAll_Key(clonedIdentity, keyName, maxDepth);\n  if (paths === [] || paths === false) return clonedIdentity;\n  paths.forEach(path => {\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var ref = clonedIdentity;\n    if (!Array.isArray(path)) delete ref[path];\n\n    for (var i = 0; i < path.length; i++) {\n      var key = path[i];\n\n      if (key in ref) {\n        if (i < path.length - 1) ref = ref[key];else delete ref[key];\n      } else break;\n    }\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, removes the first property with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction deepRemove_Key(identity, keyName, maxDepth) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  let clonedIdentity = deepClone(identity);\n  var path = locate_Key(clonedIdentity, keyName, maxDepth);\n  if (path === false) return clonedIdentity;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var ref = clonedIdentity;\n  if (!Array.isArray(path)) delete ref[path];\n  path.forEach((key, i) => {\n    if (i < path.length - 1) ref = ref[key];else delete ref[key];\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, and renames the all matching keys\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction renameKeys(identity, keyName, newKeyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n\n  function _renameKeys(identity, keyName, newKeyName, maxDepth, currentDepth = 0) {\n    let keys;\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKeys(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (key === keyName) key = newKeyName;\n          Obj[key] = _renameKeys(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKeys(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Performs deep search on object tree, then renames the first matching key\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction renameKey(identity, keyName, newKeyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n  var applied = false;\n\n  function _renameKey(identity, keyName, newKeyName, maxDepth, currentDepth = 0) {\n    let keys;\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKey(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (!applied) if (key === keyName) {\n            key = newKeyName;\n            applied = true;\n          }\n          Obj[key] = _renameKey(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKey(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Creates a non-reference clone that is an exact copy to the identity provided.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @param {Optional Number} startDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction deepClone(identity, maxDepth = null, startDepth = null) {\n  var R = [];\n\n  function _deepClone(identity, maxDepth, startDepth, currentDepth = 0) {\n    let keys;\n\n    if (startDepth !== null ? currentDepth < startDepth : false) {\n      if (isIterable(identity)) {\n        keys = Object.keys(identity);\n        keys.forEach(key => {\n          _deepClone(identity[key], maxDepth, startDepth, currentDepth + 1);\n        });\n      }\n\n      return;\n    }\n\n    if (startDepth !== null ? currentDepth == startDepth : false) {\n      if (startDepth == 0) {\n        R = _deepClone(identity, maxDepth, null, currentDepth);\n        return;\n      }\n\n      if (isIterable(identity)) R.push(_deepClone(identity, maxDepth, startDepth, currentDepth + 1));\n      return;\n    }\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          const key = keys[i],\n                subIdentity = identity[key];\n          Arr[key] = _deepClone(subIdentity, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          const key = keys[i],\n                subIdentity = identity[key];\n          Obj[key] = _deepClone(subIdentity, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  if (startDepth === null) return _deepClone(identity, maxDepth, startDepth, 0);\n\n  _deepClone(identity, maxDepth, startDepth, 0);\n\n  return R;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, and returns a list of identities containing the matched instances. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} Identities\r\n */\n\n\nfunction deepFilter_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var paths = locateAll_Key(collection, keyName, maxDepth);\n  if (paths === false) return undefined;\n  const results = paths.map(path => {\n    if (path === false) return undefined;\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(key => {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, returns the location of each match in a string array. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction locateAll_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var R = [];\n\n  function _locateAll_Key(collection, keyName, xKey = '', path = '', maxDepth = null, currentDepth = 0) {\n    if (xKey === keyName) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key];\n\n      _locateAll_Key(subcollection, keyName, key, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll_Key(collection, keyName, '', '', maxDepth);\n\n  R = R.map(path => {\n    if (getType(path) === 'boolean') return path;\n    if (path === '') return path;\n    path = path.split('.');\n    path.pop();\n    path = path.join('.');\n    return path;\n  });\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, and returns the first identity containing the match. If no match found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {Identity || undefined} identity\r\n */\n\n\nfunction deepGet_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var path = locate_Key(collection, keyName, maxDepth);\n  if (path === false) return undefined;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(key => {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, will return the path of the first instance matched. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {String || false} Path\r\n */\n\n\nfunction locate_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  function _locate_Key(collection, keyName, path = '', maxDepth, currentDepth = 0) {\n    if (path === keyName) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _locate_Key(subcollection, keyName, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  var path = _locate_Key(collection, keyName, '', maxDepth, 0);\n\n  if (getType(path) === 'boolean') return path;\n  if (path === '') return path;\n  path = path.split('.');\n  path.pop();\n  path = path.join('.');\n  return path;\n}\n/**\r\n * Performs deep search for identity on collection to return the location's depth of the first match. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean}\r\n */\n\n\nfunction matchDepth(collection, identity, maxDepth = null) {\n  var path = locate(collection, identity, maxDepth);\n  if (path === false) return false;\n  if (path === '') return 0;\n  path = path.split('.');\n  return path.length;\n}\n/**\r\n * Walks through the entire object tree to return the maximum number of layers it contains.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n */\n\n\nfunction maxDepth(identity, maxLayer = null) {\n  let R = 0;\n\n  function _maxDepth(identity, maxLayer, currentDepth = 0) {\n    if (R < currentDepth) R = currentDepth;\n    if (maxLayer !== null) if (currentDepth >= maxLayer) return;\n\n    if (isIterable(identity)) {\n      var keys = Object.keys(identity);\n      keys.forEach(key => {\n        var subIdentity = identity[key];\n\n        _maxDepth(subIdentity, maxLayer, currentDepth + 1);\n      });\n    }\n  }\n\n  _maxDepth(identity, maxLayer);\n\n  return R;\n}\n/**\r\n * Performs deep search for identity on collection, returns the number of matches found.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Number} nthDepth\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns number of matches found.\r\n */\n\n\nfunction countMatches(collection, identity, nthDepth = null, maxDepth = null) {\n  var depth,\n      nthDepth_isNull = nthDepth === null,\n      maxDepth_isNull = maxDepth === null;\n  if (nthDepth_isNull && maxDepth_isNull) depth = null;else if (!nthDepth_isNull && !maxDepth_isNull) {\n    if (nthDepth < maxDepth) depth = nthDepth;else depth = maxDepth;\n  } else if (nthDepth) depth = nthDepth;else depth = maxDepth;\n  var paths = locateAll(collection, identity, depth);\n  if (paths === false) return 0;\n  if (nthDepth === null) return paths.length;\n\n  if (getType(nthDepth) === 'number') {\n    let count = 0;\n    paths.forEach(path => {\n      path = path.split('.');\n      if (path.length === nthDepth) count++;\n    });\n    return count;\n  }\n\n  return undefined;\n}\n/**\r\n* Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n* @param {Any} collection\r\n* @param {Any} identities\r\n* @param {Any} property\r\n* @param {Optional Number} maxDepth\r\n* @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n*/\n\n\nfunction onlyFalsy(collection, identities, property, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      const subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundFalsy(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      const identity = identities[key],\n            subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundFalsy(subCollection, property, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (foundFalsy(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction foundFalsy(collection, identity, maxDepth = null) {\n  identity = singleProperty(identity);\n  if (isFalsy(identity)) return undefined;\n\n  function _foundFalsy(collection, identity, maxDepth, currentDepth = 0) {\n    if (containsKeys(collection, [identity])) return isFalsy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _foundFalsy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundFalsy(collection, identity, maxDepth);\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Any} property\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction onlyTruthy(collection, identities, property, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      const subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundTruthy(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      const identity = identities[key],\n            subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundTruthy(subCollection, property, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (foundTruthy(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction foundTruthy(collection, identity, maxDepth = null) {\n  identity = singleProperty(identity);\n  if (isFalsy(identity)) return undefined;\n\n  function _foundTruthy(collection, identity, maxDepth, currentDepth = 0) {\n    if (containsKeys(collection, [identity])) return isTruthy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _foundTruthy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundTruthy(collection, identity, maxDepth, 0);\n}\n/**\r\n * Validates if identity is equal to a property definition or contains a single property key.\r\n * @param {Property} identity\r\n * @return {String || boolean} If criteria matched will return property name as string, otherwise false\r\n */\n\n\nfunction singleProperty(identity) {\n  const propCount = length(identity);\n  if (propCount > 1) return false;\n  if (propCount === 1) return Object.keys(identity)[0];\n  if (propCount === 0) if (['string', 'number'].indexOf(getType(identity)) > -1) return identity;\n  return false;\n}\n/**\r\n * Determines if identity is non-falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction isTruthy(identity) {\n  return !isFalsy(identity);\n}\n/**\r\n * Determines if identity is falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction isFalsy(identity) {\n  if (falser(identity) === false) return true;\n  return false;\n}\n/**\r\n * Converts false-like values into actual boolean value of false\r\n * @param {Any} identity\r\n * @return {Any || boolean} Returns false is value is falsy, otherwise returns original value.\r\n */\n\n\nfunction falser(identity) {\n  if (isIterable(identity)) return identity;\n  if (['null', 'undefined'].indexOf(getType(identity)) > -1) return false;\n  if (['', 0, false].indexOf(identity) > -1) return false;\n  return identity;\n}\n/**\r\n * Check the length of the top-most depth of the identity\r\n * @param {Any} identity\r\n * @return {integer} Greater than or equal to 0.\r\n */\n\n\nfunction length(identity) {\n  if (['array', 'object'].indexOf(getType(identity)) === -1) return 0;\n  return Object.keys(identity).length;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that does meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that were not matched.\r\n */\n\n\nfunction onlyMissing(collection, identities, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      if (!exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      let identity = identities[key];\n      if (!exists(collection, identity, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (!exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction onlyExisting(collection, identities, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      if (exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      let identity = identities[key];\n      if (exists(collection, identity, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the identity\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If a match is confirmed will return true, otherwise false\r\n */\n\n\nfunction exists(collection, identity, maxDepth = null, currentDepth = 0) {\n  if (identical(collection, identity)) return true;\n  if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n    const trimmed = trim(collection, Object.keys(identity));\n    if (identical(trimmed, identity)) return true;\n  }\n  if (maxDepth === null ? true : currentDepth < maxDepth) if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n    const key = keys[i],\n          subcollection = collection[key],\n          res = exists(subcollection, identity, maxDepth, currentDepth + 1);\n    if (res) return true;\n  }\n  return false;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, will return a list of identities containing the match. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} identities\r\n */\n\n\nfunction deepFilter(collection, identity, maxDepth = null) {\n  var paths = locateAll(collection, identity, maxDepth);\n  if (paths === false) return undefined;\n  const results = paths.map(path => {\n    if (path === '') return collection;\n    path = path.split('.');\n    if (['array', 'object'].indexOf(getType(identity)) === -1) path.splice(-1, 1);\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(key => {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, returns a string array containing the location of all matches. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction locateAll(collection, identity, maxDepth = null) {\n  var R = [];\n\n  function _locateAll(collection, identity, path = '', maxDepth, currentDepth) {\n    if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n      const trimmed = trim(collection, Object.keys(identity));\n      if (identical(trimmed, identity)) R[R.length] = path;\n    }\n    if (identical(collection, identity)) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key];\n\n      _locateAll(subcollection, identity, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll(collection, identity, '', maxDepth, 0);\n\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the identity containing of the first instance matched. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {identity || undefined} identity\r\n */\n\n\nfunction deepGet(collection, identity, maxDepth = null) {\n  var path = locate(collection, identity, maxDepth);\n  if (path === false) return undefined;\n  if (path === '') return collection;\n  path = path.split('.');\n  if (['array', 'object'].indexOf(getType(identity)) === -1) path.splice(-1, 1);\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(key => {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the path of the first instance matched as string. If no matches found, returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional number} maxDepth\r\n * @return {string || false} path\r\n */\n\n\nfunction locate(collection, identity, maxDepth = null) {\n  function _locate(collection, identity, path = '', maxDepth, currentDepth) {\n    if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n      const trimmed = trim(collection, Object.keys(identity));\n      if (identical(trimmed, identity)) return path;\n    }\n    if (identical(collection, identity)) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _locate(subcollection, identity, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  return _locate(collection, identity, '', maxDepth, 0);\n}\n/**\r\n * Trims an identity to only contain the specified properties.\r\n * @param {Any} identity\r\n * @param {Any} keyList\r\n * @return {Object or Array} Returns , otherwise false\r\n */\n\n\nfunction trim(identity, keyList) {\n  const identityType = getType(identity);\n  if (['array', 'object'].indexOf(identityType) === -1) return undefined;\n  const keyCount = keyList.length;\n  if (keyCount === 0) return undefined;\n  var newIdentity;\n\n  switch (identityType) {\n    case 'object':\n      newIdentity = {};\n      keyList.forEach(key => {\n        if (key in identity) newIdentity[key] = identity[key];\n      });\n      break;\n\n    case 'array':\n      newIdentity = [];\n      keyList.forEach(key => {\n        if (key in identity) newIdentity.push(identity[key]);\n      });\n      break;\n  }\n\n  return newIdentity;\n}\n/**\r\n * Check if identity contains all of the specified keys\r\n * @param {Any} identity\r\n * @param {Array} keyList\r\n * @return {boolean} true || false\r\n */\n\n\nfunction containsKeys(identity, keyList) {\n  const keyCount = keyList.length;\n  if (keyCount === 0 || !isIterable(identity)) return false;\n  const identitykeys = Object.keys(identity);\n  var result = true;\n\n  for (var i = 0; i < keyCount; i++) {\n    const key = '' + keyList[i];\n\n    if (identitykeys.indexOf(key) === -1) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n}\n/**\r\n * Check if identity has one or more keys to iterate\r\n * @param {Any} identity\r\n * @return {boolean} true || false\r\n */\n\n\nfunction isIterable(identity) {\n  if (['array', 'object'].indexOf(getType(identity)) === -1) return false;\n  if (Object.keys(identity).length === 0) return false;\n  return true;\n}\n/**\r\n * Compares two identities, will return either true if identical, otherwise false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction identical(identityA, identityB) {\n  const structureMatch = sameStructure(identityA, identityB);\n  if (structureMatch === false) return structureMatch;\n  if (['array', 'object'].indexOf(structureMatch) === -1) return identityA === identityB;\n  const Keys = Object.keys(identityA),\n        KeyCount = Keys.length;\n  var childMatch = true;\n\n  for (var i = 0; i < KeyCount; i++) {\n    const Key = Keys[i],\n          identicalMatch = identical(identityA[Key], identityB[Key]);\n\n    if (identicalMatch === false) {\n      childMatch = identicalMatch;\n      break;\n    }\n\n    ;\n  }\n\n  return childMatch;\n}\n/**\r\n * Compares data structure of two identities, will return either the dataType or true/false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {String || False} DataType as string for positive match, otherwise false\r\n */\n\n\nfunction sameStructure(identityA, identityB) {\n  const typeMatch = sameType(identityA, identityB);\n  if (typeMatch === false) return false;\n\n  if (['array', 'object'].indexOf(typeMatch) > -1) {\n    const AKeys = Object.keys(identityA),\n          BKeys = Object.keys(identityB),\n          AKeyCount = AKeys.length,\n          BKeyCount = BKeys.length;\n    if (!(AKeyCount === BKeyCount)) return false;\n    if (AKeyCount === 0) return true;\n\n    for (var i = 0; i < AKeyCount; i++) {\n      if (AKeys[i] !== BKeys[i]) return false;\n    }\n  }\n\n  return typeMatch;\n}\n/**\r\n * Compares data type of two identities, will dataType if true.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction sameType(identityA, identityB) {\n  const typeA = getType(identityA);\n  return typeA === getType(identityB) ? typeA : false;\n}\n/**\r\n * Gets data type; makes distintion between object, array, and null.\r\n * @param {Any} identity\r\n * @return {String} dataType\r\n */\n\n\nfunction getType(identity) {\n  if (identity === null) return 'null';\n  const it = typeof identity;\n  if (it === 'object') if (Array.isArray(identity)) return 'array';\n  return it;\n}\n\nvar mitsuketa = {\n  getType: function (identity) {\n    return getType(identity);\n  },\n  sameType: function (identityA, identityB) {\n    return sameType(identityA, identityB);\n  },\n  sameStructure: function (identityA, identityB) {\n    return sameStructure(identityA, identityB);\n  },\n  identical: function (identityA, identityB) {\n    return identical(identityA, identityB);\n  },\n  isIterable: function (identity) {\n    return isIterable(identity);\n  },\n  containsKeys: function (identity, keyList) {\n    return containsKeys(identity, keyList);\n  },\n  trim: function (identity, keyList) {\n    return trim(identity, keyList);\n  },\n  locate: function (collection, identity, maxDepth) {\n    return locate(collection, identity, maxDepth);\n  },\n  deepGet: function (collection, identity, maxDepth) {\n    return deepGet(collection, identity, maxDepth);\n  },\n  locateAll: function (collection, identity, maxDepth) {\n    return locateAll(collection, identity, maxDepth);\n  },\n  deepFilter: function (collection, identity, maxDepth) {\n    return deepFilter(collection, identity, maxDepth);\n  },\n  exists: function (collection, identity, maxDepth) {\n    return exists(collection, identity, maxDepth);\n  },\n  onlyExisting: function (collection, identities, maxDepth) {\n    return onlyExisting(collection, identities, maxDepth);\n  },\n  onlyMissing: function (collection, identities, maxDepth) {\n    return onlyMissing(collection, identities, maxDepth);\n  },\n  length: function (identity) {\n    return length(identity);\n  },\n  isFalsy: function (identity) {\n    return isFalsy(identity);\n  },\n  isTruthy: function (identity) {\n    return isTruthy(identity);\n  },\n  foundTruthy: function (collection, identity, maxDepth) {\n    return foundTruthy(collection, identity, maxDepth);\n  },\n  onlyTruthy: function (collection, identities, property, maxDepth) {\n    return onlyTruthy(collection, identities, property, maxDepth);\n  },\n  foundFalsy: function (collection, identity, maxDepth) {\n    return foundFalsy(collection, identity, maxDepth);\n  },\n  onlyFalsy: function (collection, identities, property, maxDepth) {\n    return onlyFalsy(collection, identities, property, maxDepth);\n  },\n  countMatches: function (collection, identity, nthDepth, maxDepth) {\n    return countMatches(collection, identity, nthDepth, maxDepth);\n  },\n  matchDepth: function (collection, identity, maxDepth) {\n    return matchDepth(collection, identity, maxDepth);\n  },\n  maxDepth: function (identity, maxLayer) {\n    return maxDepth(identity, maxLayer);\n  },\n  locate_Key: function (collection, keyName, maxDepth) {\n    return locate_Key(collection, keyName, maxDepth);\n  },\n  deepGet_Key: function (collection, keyName, maxDepth) {\n    return deepGet_Key(collection, keyName, maxDepth);\n  },\n  locateAll_Key: function (collection, keyName, maxDepth) {\n    return locateAll_Key(collection, keyName, maxDepth);\n  },\n  deepFilter_Key: function (collection, keyName, maxDepth) {\n    return deepFilter_Key(collection, keyName, maxDepth);\n  },\n  deepClone: function (identity, maxDepth, startDepth) {\n    return deepClone(identity, maxDepth, startDepth);\n  },\n  renameKey: function (identity, keyName, newKeyName, maxDepth) {\n    return renameKey(identity, keyName, newKeyName, maxDepth);\n  },\n  renameKeys: function (identity, keyName, newKeyName, maxDepth) {\n    return renameKeys(identity, keyName, newKeyName, maxDepth);\n  },\n  deepRemove_Key: function (identity, keyName, maxDepth) {\n    return deepRemove_Key(identity, keyName, maxDepth);\n  },\n  deepRemoveAll_Key: function (identity, keyName, maxDepth) {\n    return deepRemoveAll_Key(identity, keyName, maxDepth);\n  }\n};\nmodule.exports = exports = mitsuketa;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9taXRzdWtldGEvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy9taXRzdWtldGEvaW5kZXguanM/MWRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGF1dGhvciBBbmRyZXcgUmVkaWNhbiA8YW5kcmV3LnJlZGljYW4ubWVqaWFAZ21haWwuY29tPlxyXG4gKi9cblxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIG9uIG9iamVjdCB0cmVlLCByZW1vdmVzIGFsbCBwcm9wZXJ0aWVzIHdpdGggbWF0Y2hpbmcga2V5LCByZXR1cm5zIGEgbmV3IGlkZW50aXR5IHdpdGhvdXQgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleU5hbWVcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge0FueX0gaWRlbnRpdHlcclxuICovXG5mdW5jdGlvbiBkZWVwUmVtb3ZlQWxsX0tleShpZGVudGl0eSwga2V5TmFtZSwgbWF4RGVwdGgpIHtcbiAgaWYgKGdldFR5cGUoa2V5TmFtZSkgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAoa2V5TmFtZSA9PT0gJycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGxldCBjbG9uZWRJZGVudGl0eSA9IGRlZXBDbG9uZShpZGVudGl0eSk7XG4gIHZhciBwYXRocyA9IGxvY2F0ZUFsbF9LZXkoY2xvbmVkSWRlbnRpdHksIGtleU5hbWUsIG1heERlcHRoKTtcbiAgaWYgKHBhdGhzID09PSBbXSB8fCBwYXRocyA9PT0gZmFsc2UpIHJldHVybiBjbG9uZWRJZGVudGl0eTtcbiAgcGF0aHMuZm9yRWFjaChwYXRoID0+IHtcbiAgICBpZiAocGF0aCA9PT0gJycpIHBhdGggPSBrZXlOYW1lO2Vsc2UgcGF0aCArPSAnLicgKyBrZXlOYW1lO1xuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIHJlZiA9IGNsb25lZElkZW50aXR5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSkgZGVsZXRlIHJlZltwYXRoXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChrZXkgaW4gcmVmKSB7XG4gICAgICAgIGlmIChpIDwgcGF0aC5sZW5ndGggLSAxKSByZWYgPSByZWZba2V5XTtlbHNlIGRlbGV0ZSByZWZba2V5XTtcbiAgICAgIH0gZWxzZSBicmVhaztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xvbmVkSWRlbnRpdHk7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gb2JqZWN0IHRyZWUsIHJlbW92ZXMgdGhlIGZpcnN0IHByb3BlcnR5IHdpdGggbWF0Y2hpbmcga2V5LCByZXR1cm5zIGEgbmV3IGlkZW50aXR5IHdpdGhvdXQgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleU5hbWVcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge0FueX0gaWRlbnRpdHlcclxuICovXG5cblxuZnVuY3Rpb24gZGVlcFJlbW92ZV9LZXkoaWRlbnRpdHksIGtleU5hbWUsIG1heERlcHRoKSB7XG4gIGlmIChnZXRUeXBlKGtleU5hbWUpICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKGtleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBsZXQgY2xvbmVkSWRlbnRpdHkgPSBkZWVwQ2xvbmUoaWRlbnRpdHkpO1xuICB2YXIgcGF0aCA9IGxvY2F0ZV9LZXkoY2xvbmVkSWRlbnRpdHksIGtleU5hbWUsIG1heERlcHRoKTtcbiAgaWYgKHBhdGggPT09IGZhbHNlKSByZXR1cm4gY2xvbmVkSWRlbnRpdHk7XG4gIGlmIChwYXRoID09PSAnJykgcGF0aCA9IGtleU5hbWU7ZWxzZSBwYXRoICs9ICcuJyArIGtleU5hbWU7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciByZWYgPSBjbG9uZWRJZGVudGl0eTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKSBkZWxldGUgcmVmW3BhdGhdO1xuICBwYXRoLmZvckVhY2goKGtleSwgaSkgPT4ge1xuICAgIGlmIChpIDwgcGF0aC5sZW5ndGggLSAxKSByZWYgPSByZWZba2V5XTtlbHNlIGRlbGV0ZSByZWZba2V5XTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZWRJZGVudGl0eTtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBvYmplY3QgdHJlZSwgYW5kIHJlbmFtZXMgdGhlIGFsbCBtYXRjaGluZyBrZXlzXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5TmFtZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3S2V5TmFtZVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QW55fSBpZGVudGl0eVxyXG4gKi9cblxuXG5mdW5jdGlvbiByZW5hbWVLZXlzKGlkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgaWYgKGdldFR5cGUoa2V5TmFtZSkgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAoZ2V0VHlwZShuZXdLZXlOYW1lKSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChrZXlOYW1lID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKG5ld0tleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIF9yZW5hbWVLZXlzKGlkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCwgY3VycmVudERlcHRoID0gMCkge1xuICAgIGxldCBrZXlzO1xuXG4gICAgc3dpdGNoIChnZXRUeXBlKGlkZW50aXR5KSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICB2YXIgQXJyID0gW107XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhpZGVudGl0eSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGxldCBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgICBzdWJJZGVudGl0eSA9IGlkZW50aXR5W2tleV07XG4gICAgICAgICAgQXJyW2tleV0gPSBfcmVuYW1lS2V5cyhzdWJJZGVudGl0eSwga2V5TmFtZSwgbmV3S2V5TmFtZSwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycjtcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgdmFyIE9iaiA9IHt9O1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsZXQga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgICAgc3ViSWRlbnRpdHkgPSBpZGVudGl0eVtrZXldO1xuICAgICAgICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCA/IGN1cnJlbnREZXB0aCA8IG1heERlcHRoIDogdHJ1ZSkgaWYgKGtleSA9PT0ga2V5TmFtZSkga2V5ID0gbmV3S2V5TmFtZTtcbiAgICAgICAgICBPYmpba2V5XSA9IF9yZW5hbWVLZXlzKHN1YklkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gJycgKyBpZGVudGl0eTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIDAgKyBpZGVudGl0eTtcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGlmIChpZGVudGl0eSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfcmVuYW1lS2V5cyhpZGVudGl0eSwga2V5TmFtZSwgbmV3S2V5TmFtZSwgbWF4RGVwdGgsIDApO1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIG9uIG9iamVjdCB0cmVlLCB0aGVuIHJlbmFtZXMgdGhlIGZpcnN0IG1hdGNoaW5nIGtleVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleU5hbWVcclxuICogQHBhcmFtIHtzdHJpbmd9IG5ld0tleU5hbWVcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge0FueX0gaWRlbnRpdHlcclxuICovXG5cblxuZnVuY3Rpb24gcmVuYW1lS2V5KGlkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgaWYgKGdldFR5cGUoa2V5TmFtZSkgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAoZ2V0VHlwZShuZXdLZXlOYW1lKSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChrZXlOYW1lID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKG5ld0tleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgYXBwbGllZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIF9yZW5hbWVLZXkoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoLCBjdXJyZW50RGVwdGggPSAwKSB7XG4gICAgbGV0IGtleXM7XG5cbiAgICBzd2l0Y2ggKGdldFR5cGUoaWRlbnRpdHkpKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIHZhciBBcnIgPSBbXTtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICAgIHN1YklkZW50aXR5ID0gaWRlbnRpdHlba2V5XTtcbiAgICAgICAgICBBcnJba2V5XSA9IF9yZW5hbWVLZXkoc3ViSWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBcnI7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHZhciBPYmogPSB7fTtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICAgIHN1YklkZW50aXR5ID0gaWRlbnRpdHlba2V5XTtcbiAgICAgICAgICBpZiAobWF4RGVwdGggIT09IG51bGwgPyBjdXJyZW50RGVwdGggPCBtYXhEZXB0aCA6IHRydWUpIGlmICghYXBwbGllZCkgaWYgKGtleSA9PT0ga2V5TmFtZSkge1xuICAgICAgICAgICAga2V5ID0gbmV3S2V5TmFtZTtcbiAgICAgICAgICAgIGFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmpba2V5XSA9IF9yZW5hbWVLZXkoc3ViSWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmo7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiAnJyArIGlkZW50aXR5O1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gMCArIGlkZW50aXR5O1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgaWYgKGlkZW50aXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yZW5hbWVLZXkoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoLCAwKTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbm9uLXJlZmVyZW5jZSBjbG9uZSB0aGF0IGlzIGFuIGV4YWN0IGNvcHkgdG8gdGhlIGlkZW50aXR5IHByb3ZpZGVkLlxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBzdGFydERlcHRoXHJcbiAqIEByZXR1cm4ge0FueX0gaWRlbnRpdHlcclxuICovXG5cblxuZnVuY3Rpb24gZGVlcENsb25lKGlkZW50aXR5LCBtYXhEZXB0aCA9IG51bGwsIHN0YXJ0RGVwdGggPSBudWxsKSB7XG4gIHZhciBSID0gW107XG5cbiAgZnVuY3Rpb24gX2RlZXBDbG9uZShpZGVudGl0eSwgbWF4RGVwdGgsIHN0YXJ0RGVwdGgsIGN1cnJlbnREZXB0aCA9IDApIHtcbiAgICBsZXQga2V5cztcblxuICAgIGlmIChzdGFydERlcHRoICE9PSBudWxsID8gY3VycmVudERlcHRoIDwgc3RhcnREZXB0aCA6IGZhbHNlKSB7XG4gICAgICBpZiAoaXNJdGVyYWJsZShpZGVudGl0eSkpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5KTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgX2RlZXBDbG9uZShpZGVudGl0eVtrZXldLCBtYXhEZXB0aCwgc3RhcnREZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVwdGggIT09IG51bGwgPyBjdXJyZW50RGVwdGggPT0gc3RhcnREZXB0aCA6IGZhbHNlKSB7XG4gICAgICBpZiAoc3RhcnREZXB0aCA9PSAwKSB7XG4gICAgICAgIFIgPSBfZGVlcENsb25lKGlkZW50aXR5LCBtYXhEZXB0aCwgbnVsbCwgY3VycmVudERlcHRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJdGVyYWJsZShpZGVudGl0eSkpIFIucHVzaChfZGVlcENsb25lKGlkZW50aXR5LCBtYXhEZXB0aCwgc3RhcnREZXB0aCwgY3VycmVudERlcHRoICsgMSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZ2V0VHlwZShpZGVudGl0eSkpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgdmFyIEFyciA9IFtdO1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xuICAgICAgICBpZiAobWF4RGVwdGggIT09IG51bGwgPyBjdXJyZW50RGVwdGggPCBtYXhEZXB0aCA6IHRydWUpIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgICAgIHN1YklkZW50aXR5ID0gaWRlbnRpdHlba2V5XTtcbiAgICAgICAgICBBcnJba2V5XSA9IF9kZWVwQ2xvbmUoc3ViSWRlbnRpdHksIG1heERlcHRoLCBzdGFydERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB2YXIgT2JqID0ge307XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhpZGVudGl0eSk7XG4gICAgICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCA/IGN1cnJlbnREZXB0aCA8IG1heERlcHRoIDogdHJ1ZSkgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICAgICAgc3ViSWRlbnRpdHkgPSBpZGVudGl0eVtrZXldO1xuICAgICAgICAgIE9ialtrZXldID0gX2RlZXBDbG9uZShzdWJJZGVudGl0eSwgbWF4RGVwdGgsIHN0YXJ0RGVwdGgsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmo7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiAnJyArIGlkZW50aXR5O1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gMCArIGlkZW50aXR5O1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgaWYgKGlkZW50aXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RGVwdGggPT09IG51bGwpIHJldHVybiBfZGVlcENsb25lKGlkZW50aXR5LCBtYXhEZXB0aCwgc3RhcnREZXB0aCwgMCk7XG5cbiAgX2RlZXBDbG9uZShpZGVudGl0eSwgbWF4RGVwdGgsIHN0YXJ0RGVwdGgsIDApO1xuXG4gIHJldHVybiBSO1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIG9uIGNvbGxlY3Rpb24gdG8gZmluZCBhbGwgbWF0Y2hlcyB0byB0aGUga2V5IG5hbWUsIGFuZCByZXR1cm5zIGEgbGlzdCBvZiBpZGVudGl0aWVzIGNvbnRhaW5pbmcgdGhlIG1hdGNoZWQgaW5zdGFuY2VzLiBJZiBubyBtYXRjaGVzIGZvdW5kLCBpdCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0ga2V5TmFtZVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QXJyYXkgfHwgdW5kZWZpbmVkfSBJZGVudGl0aWVzXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBGaWx0ZXJfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShrZXlOYW1lKSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChrZXlOYW1lID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIHBhdGhzID0gbG9jYXRlQWxsX0tleShjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCk7XG4gIGlmIChwYXRocyA9PT0gZmFsc2UpIHJldHVybiB1bmRlZmluZWQ7XG4gIGNvbnN0IHJlc3VsdHMgPSBwYXRocy5tYXAocGF0aCA9PiB7XG4gICAgaWYgKHBhdGggPT09IGZhbHNlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChwYXRoID09PSAnJykgcGF0aCA9IGtleU5hbWU7ZWxzZSBwYXRoICs9ICcuJyArIGtleU5hbWU7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB2YXIgcmVzdWx0ID0gY29sbGVjdGlvbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHJldHVybiByZXN1bHRbcGF0aF07XG4gICAgcGF0aC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICByZXN1bHQgPSByZXN1bHRba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGFsbCBtYXRjaGVzIHRvIHRoZSBrZXkgbmFtZSwgcmV0dXJucyB0aGUgbG9jYXRpb24gb2YgZWFjaCBtYXRjaCBpbiBhIHN0cmluZyBhcnJheS4gSWYgbm8gbWF0Y2hlcyBmb3VuZCwgaXQgcmV0dXJucyBgZmFsc2VgLlxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0ga2V5TmFtZVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QXJyYXkgfHwgZmFsc2V9IFBhdGhzXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2F0ZUFsbF9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIGlmIChnZXRUeXBlKGtleU5hbWUpICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKGtleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgUiA9IFtdO1xuXG4gIGZ1bmN0aW9uIF9sb2NhdGVBbGxfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIHhLZXkgPSAnJywgcGF0aCA9ICcnLCBtYXhEZXB0aCA9IG51bGwsIGN1cnJlbnREZXB0aCA9IDApIHtcbiAgICBpZiAoeEtleSA9PT0ga2V5TmFtZSkgUltSLmxlbmd0aF0gPSBwYXRoO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAobWF4RGVwdGggIT09IG51bGwpIGlmIChjdXJyZW50RGVwdGggPj0gbWF4RGVwdGgpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGlzSXRlcmFibGUoY29sbGVjdGlvbikpIGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbiksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgIHN1YmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uW2tleV07XG5cbiAgICAgIF9sb2NhdGVBbGxfS2V5KHN1YmNvbGxlY3Rpb24sIGtleU5hbWUsIGtleSwgKHBhdGggPT09ICcnID8gcGF0aCA6IHBhdGggKyAnLicpICsga2V5LCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG4gICAgfVxuICB9XG5cbiAgX2xvY2F0ZUFsbF9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgJycsICcnLCBtYXhEZXB0aCk7XG5cbiAgUiA9IFIubWFwKHBhdGggPT4ge1xuICAgIGlmIChnZXRUeXBlKHBhdGgpID09PSAnYm9vbGVhbicpIHJldHVybiBwYXRoO1xuICAgIGlmIChwYXRoID09PSAnJykgcmV0dXJuIHBhdGg7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBwYXRoLnBvcCgpO1xuICAgIHBhdGggPSBwYXRoLmpvaW4oJy4nKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSk7XG4gIHJldHVybiBSLmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogUjtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBjb2xsZWN0aW9uIHRvIGZpbmQgYSBtYXRjaCB0byB0aGUga2V5IG5hbWUsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBpZGVudGl0eSBjb250YWluaW5nIHRoZSBtYXRjaC4gSWYgbm8gbWF0Y2ggZm91bmQsIGl0IHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7QW55fSBrZXlOYW1lXHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgbnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtJZGVudGl0eSB8fCB1bmRlZmluZWR9IGlkZW50aXR5XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBHZXRfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShrZXlOYW1lKSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChrZXlOYW1lID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIHBhdGggPSBsb2NhdGVfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIG1heERlcHRoKTtcbiAgaWYgKHBhdGggPT09IGZhbHNlKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAocGF0aCA9PT0gJycpIHBhdGggPSBrZXlOYW1lO2Vsc2UgcGF0aCArPSAnLicgKyBrZXlOYW1lO1xuICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgcmVzdWx0ID0gY29sbGVjdGlvbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKSByZXR1cm4gcmVzdWx0W3BhdGhdO1xuICBwYXRoLmZvckVhY2goa2V5ID0+IHtcbiAgICByZXN1bHQgPSByZXN1bHRba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGEgbWF0Y2ggdG8gdGhlIGtleSBuYW1lLCB3aWxsIHJldHVybiB0aGUgcGF0aCBvZiB0aGUgZmlyc3QgaW5zdGFuY2UgbWF0Y2hlZC4gSWYgbm8gbWF0Y2ggZm91bmQsIGl0IHJldHVybnMgYGZhbHNlYC5cclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGtleU5hbWVcclxuICogQHBhcmFtIHtPcHRpb25hbCBudW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge1N0cmluZyB8fCBmYWxzZX0gUGF0aFxyXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhdGVfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShrZXlOYW1lKSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChrZXlOYW1lID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBfbG9jYXRlX0tleShjb2xsZWN0aW9uLCBrZXlOYW1lLCBwYXRoID0gJycsIG1heERlcHRoLCBjdXJyZW50RGVwdGggPSAwKSB7XG4gICAgaWYgKHBhdGggPT09IGtleU5hbWUpIHJldHVybiBwYXRoO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAobWF4RGVwdGggIT09IG51bGwpIGlmIChjdXJyZW50RGVwdGggPj0gbWF4RGVwdGgpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGlzSXRlcmFibGUoY29sbGVjdGlvbikpIGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbiksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgIHN1YmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uW2tleV0sXG4gICAgICAgICAgICByZXMgPSBfbG9jYXRlX0tleShzdWJjb2xsZWN0aW9uLCBrZXlOYW1lLCBrZXksIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcblxuICAgICAgaWYgKHJlcykge1xuICAgICAgICBwYXRoID0gcGF0aCA9PT0gJycgPyBwYXRoIDogcGF0aCArICcuJztcbiAgICAgICAgcmVzdWx0ID0gcGF0aCArIHJlcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgcGF0aCA9IF9sb2NhdGVfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsICcnLCBtYXhEZXB0aCwgMCk7XG5cbiAgaWYgKGdldFR5cGUocGF0aCkgPT09ICdib29sZWFuJykgcmV0dXJuIHBhdGg7XG4gIGlmIChwYXRoID09PSAnJykgcmV0dXJuIHBhdGg7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHBhdGgucG9wKCk7XG4gIHBhdGggPSBwYXRoLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHBhdGg7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggZm9yIGlkZW50aXR5IG9uIGNvbGxlY3Rpb24gdG8gcmV0dXJuIHRoZSBsb2NhdGlvbidzIGRlcHRoIG9mIHRoZSBmaXJzdCBtYXRjaC4gSWYgbm8gbWF0Y2ggZm91bmQsIGl0IHJldHVybnMgYGZhbHNlYC5cclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXRjaERlcHRoKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgdmFyIHBhdGggPSBsb2NhdGUoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKTtcbiAgaWYgKHBhdGggPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwYXRoID09PSAnJykgcmV0dXJuIDA7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBwYXRoLmxlbmd0aDtcbn1cbi8qKlxyXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSBlbnRpcmUgb2JqZWN0IHRyZWUgdG8gcmV0dXJuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBsYXllcnMgaXQgY29udGFpbnMuXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICovXG5cblxuZnVuY3Rpb24gbWF4RGVwdGgoaWRlbnRpdHksIG1heExheWVyID0gbnVsbCkge1xuICBsZXQgUiA9IDA7XG5cbiAgZnVuY3Rpb24gX21heERlcHRoKGlkZW50aXR5LCBtYXhMYXllciwgY3VycmVudERlcHRoID0gMCkge1xuICAgIGlmIChSIDwgY3VycmVudERlcHRoKSBSID0gY3VycmVudERlcHRoO1xuICAgIGlmIChtYXhMYXllciAhPT0gbnVsbCkgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhMYXllcikgcmV0dXJuO1xuXG4gICAgaWYgKGlzSXRlcmFibGUoaWRlbnRpdHkpKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5KTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICB2YXIgc3ViSWRlbnRpdHkgPSBpZGVudGl0eVtrZXldO1xuXG4gICAgICAgIF9tYXhEZXB0aChzdWJJZGVudGl0eSwgbWF4TGF5ZXIsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX21heERlcHRoKGlkZW50aXR5LCBtYXhMYXllcik7XG5cbiAgcmV0dXJuIFI7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggZm9yIGlkZW50aXR5IG9uIGNvbGxlY3Rpb24sIHJldHVybnMgdGhlIG51bWJlciBvZiBtYXRjaGVzIGZvdW5kLlxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG50aERlcHRoXHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtBbnl9IFJldHVybnMgbnVtYmVyIG9mIG1hdGNoZXMgZm91bmQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50TWF0Y2hlcyhjb2xsZWN0aW9uLCBpZGVudGl0eSwgbnRoRGVwdGggPSBudWxsLCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgdmFyIGRlcHRoLFxuICAgICAgbnRoRGVwdGhfaXNOdWxsID0gbnRoRGVwdGggPT09IG51bGwsXG4gICAgICBtYXhEZXB0aF9pc051bGwgPSBtYXhEZXB0aCA9PT0gbnVsbDtcbiAgaWYgKG50aERlcHRoX2lzTnVsbCAmJiBtYXhEZXB0aF9pc051bGwpIGRlcHRoID0gbnVsbDtlbHNlIGlmICghbnRoRGVwdGhfaXNOdWxsICYmICFtYXhEZXB0aF9pc051bGwpIHtcbiAgICBpZiAobnRoRGVwdGggPCBtYXhEZXB0aCkgZGVwdGggPSBudGhEZXB0aDtlbHNlIGRlcHRoID0gbWF4RGVwdGg7XG4gIH0gZWxzZSBpZiAobnRoRGVwdGgpIGRlcHRoID0gbnRoRGVwdGg7ZWxzZSBkZXB0aCA9IG1heERlcHRoO1xuICB2YXIgcGF0aHMgPSBsb2NhdGVBbGwoY29sbGVjdGlvbiwgaWRlbnRpdHksIGRlcHRoKTtcbiAgaWYgKHBhdGhzID09PSBmYWxzZSkgcmV0dXJuIDA7XG4gIGlmIChudGhEZXB0aCA9PT0gbnVsbCkgcmV0dXJuIHBhdGhzLmxlbmd0aDtcblxuICBpZiAoZ2V0VHlwZShudGhEZXB0aCkgPT09ICdudW1iZXInKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gbnRoRGVwdGgpIGNvdW50Kys7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxyXG4qIFBlcmZvcm1zIGRlZXAgc2VhcmNoIGZvciBlYWNoIGlkZW50aXR5IG9uIGNvbGxlY3Rpb24sIHRvIHNob3J0ZW4gdGhlIGlkZW50aXRpZXMgdG8gdGhvc2UgdGhhdCBtZWV0cyB0aGUgbWF0Y2ggY3JpdGVyaWFcclxuKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4qIEBwYXJhbSB7QW55fSBpZGVudGl0aWVzXHJcbiogQHBhcmFtIHtBbnl9IHByb3BlcnR5XHJcbiogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiogQHJldHVybiB7QW55fSBSZXR1cm5zIGEgY29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSAnaWRlbnRpdGllcycgcGFyYW1ldGVyIHByb3ZpZGVkIHdpdGggb25seSB0aGUgaWRlbnRpdGllcyB0aGF0IG1hdGNoZWQuXHJcbiovXG5cblxuZnVuY3Rpb24gb25seUZhbHN5KGNvbGxlY3Rpb24sIGlkZW50aXRpZXMsIHByb3BlcnR5LCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgaWYgKGdldFR5cGUoaWRlbnRpdGllcykgPT09ICdhcnJheScpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWRlbnRpdGllcy5mb3JFYWNoKGlkZW50aXR5ID0+IHtcbiAgICAgIGNvbnN0IHN1YkNvbGxlY3Rpb24gPSBkZWVwRmlsdGVyKGNvbGxlY3Rpb24sIGlkZW50aXR5KTtcbiAgICAgIGlmIChpc1RydXRoeShzdWJDb2xsZWN0aW9uKSkgaWYgKGZvdW5kRmFsc3koc3ViQ29sbGVjdGlvbiwgcHJvcGVydHksIG1heERlcHRoKSkgcmVzdWx0LnB1c2goaWRlbnRpdHkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoZ2V0VHlwZShpZGVudGl0aWVzKSA9PT0gJ29iamVjdCcpIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMoaWRlbnRpdGllcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpdHkgPSBpZGVudGl0aWVzW2tleV0sXG4gICAgICAgICAgICBzdWJDb2xsZWN0aW9uID0gZGVlcEZpbHRlcihjb2xsZWN0aW9uLCBpZGVudGl0eSk7XG4gICAgICBpZiAoaXNUcnV0aHkoc3ViQ29sbGVjdGlvbikpIGlmIChmb3VuZEZhbHN5KHN1YkNvbGxlY3Rpb24sIHByb3BlcnR5LCBtYXhEZXB0aCkpIHJlc3VsdFtrZXldID0gaWRlbnRpdHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChmb3VuZEZhbHN5KGNvbGxlY3Rpb24sIHByb3BlcnR5LCBtYXhEZXB0aCkpIHJldHVybiBpZGVudGl0aWVzO1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIG9uIGNvbGxlY3Rpb24gdG8gZmluZCBhbnkgbWF0Y2ggdG8gdGhlIHByb3BlcnR5IGFuZCBldmFsdXRhdGVzIGlmIHRydXRoeVxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge1Byb3BlcnR5fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgbWF0Y2ggY29uZmlybWVkIGFuZCB0cnV0aHkgd2lsbCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvdW5kRmFsc3koY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCkge1xuICBpZGVudGl0eSA9IHNpbmdsZVByb3BlcnR5KGlkZW50aXR5KTtcbiAgaWYgKGlzRmFsc3koaWRlbnRpdHkpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIF9mb3VuZEZhbHN5KGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCwgY3VycmVudERlcHRoID0gMCkge1xuICAgIGlmIChjb250YWluc0tleXMoY29sbGVjdGlvbiwgW2lkZW50aXR5XSkpIHJldHVybiBpc0ZhbHN5KGNvbGxlY3Rpb25baWRlbnRpdHldKTtcbiAgICBpZiAobWF4RGVwdGggIT09IG51bGwpIGlmIChjdXJyZW50RGVwdGggPj0gbWF4RGVwdGgpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaXNJdGVyYWJsZShjb2xsZWN0aW9uKSkgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgc3ViY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25ba2V5XSxcbiAgICAgICAgICAgIHJlcyA9IF9mb3VuZEZhbHN5KHN1YmNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG5cbiAgICAgIGlmIChyZXMpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2ZvdW5kRmFsc3koY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKTtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBmb3IgZWFjaCBpZGVudGl0eSBvbiBjb2xsZWN0aW9uLCB0byBzaG9ydGVuIHRoZSBpZGVudGl0aWVzIHRvIHRob3NlIHRoYXQgbWVldHMgdGhlIG1hdGNoIGNyaXRlcmlhXHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0aWVzXHJcbiAqIEBwYXJhbSB7QW55fSBwcm9wZXJ0eVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QW55fSBSZXR1cm5zIGEgY29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSAnaWRlbnRpdGllcycgcGFyYW1ldGVyIHByb3ZpZGVkIHdpdGggb25seSB0aGUgaWRlbnRpdGllcyB0aGF0IG1hdGNoZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlUcnV0aHkoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgcHJvcGVydHksIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShpZGVudGl0aWVzKSA9PT0gJ2FycmF5Jykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZGVudGl0aWVzLmZvckVhY2goaWRlbnRpdHkgPT4ge1xuICAgICAgY29uc3Qgc3ViQ29sbGVjdGlvbiA9IGRlZXBGaWx0ZXIoY29sbGVjdGlvbiwgaWRlbnRpdHkpO1xuICAgICAgaWYgKGlzVHJ1dGh5KHN1YkNvbGxlY3Rpb24pKSBpZiAoZm91bmRUcnV0aHkoc3ViQ29sbGVjdGlvbiwgcHJvcGVydHksIG1heERlcHRoKSkgcmVzdWx0LnB1c2goaWRlbnRpdHkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoZ2V0VHlwZShpZGVudGl0aWVzKSA9PT0gJ29iamVjdCcpIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMoaWRlbnRpdGllcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpdHkgPSBpZGVudGl0aWVzW2tleV0sXG4gICAgICAgICAgICBzdWJDb2xsZWN0aW9uID0gZGVlcEZpbHRlcihjb2xsZWN0aW9uLCBpZGVudGl0eSk7XG4gICAgICBpZiAoaXNUcnV0aHkoc3ViQ29sbGVjdGlvbikpIGlmIChmb3VuZFRydXRoeShzdWJDb2xsZWN0aW9uLCBwcm9wZXJ0eSwgbWF4RGVwdGgpKSByZXN1bHRba2V5XSA9IGlkZW50aXR5O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoZm91bmRUcnV0aHkoY29sbGVjdGlvbiwgcHJvcGVydHksIG1heERlcHRoKSkgcmV0dXJuIGlkZW50aXRpZXM7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGFueSBtYXRjaCB0byB0aGUgcHJvcGVydHkgYW5kIGV2YWx1dGF0ZXMgaWYgdHJ1dGh5XHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7UHJvcGVydHl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiBtYXRjaCBjb25maXJtZWQgYW5kIHRydXRoeSB3aWxsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgZmFsc2VcclxuICovXG5cblxuZnVuY3Rpb24gZm91bmRUcnV0aHkoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCkge1xuICBpZGVudGl0eSA9IHNpbmdsZVByb3BlcnR5KGlkZW50aXR5KTtcbiAgaWYgKGlzRmFsc3koaWRlbnRpdHkpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIF9mb3VuZFRydXRoeShjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCA9IDApIHtcbiAgICBpZiAoY29udGFpbnNLZXlzKGNvbGxlY3Rpb24sIFtpZGVudGl0eV0pKSByZXR1cm4gaXNUcnV0aHkoY29sbGVjdGlvbltpZGVudGl0eV0pO1xuICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCkgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChpc0l0ZXJhYmxlKGNvbGxlY3Rpb24pKSBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICBzdWJjb2xsZWN0aW9uID0gY29sbGVjdGlvbltrZXldLFxuICAgICAgICAgICAgcmVzID0gX2ZvdW5kVHJ1dGh5KHN1YmNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG5cbiAgICAgIGlmIChyZXMpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2ZvdW5kVHJ1dGh5KGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCwgMCk7XG59XG4vKipcclxuICogVmFsaWRhdGVzIGlmIGlkZW50aXR5IGlzIGVxdWFsIHRvIGEgcHJvcGVydHkgZGVmaW5pdGlvbiBvciBjb250YWlucyBhIHNpbmdsZSBwcm9wZXJ0eSBrZXkuXHJcbiAqIEBwYXJhbSB7UHJvcGVydHl9IGlkZW50aXR5XHJcbiAqIEByZXR1cm4ge1N0cmluZyB8fCBib29sZWFufSBJZiBjcml0ZXJpYSBtYXRjaGVkIHdpbGwgcmV0dXJuIHByb3BlcnR5IG5hbWUgYXMgc3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcclxuICovXG5cblxuZnVuY3Rpb24gc2luZ2xlUHJvcGVydHkoaWRlbnRpdHkpIHtcbiAgY29uc3QgcHJvcENvdW50ID0gbGVuZ3RoKGlkZW50aXR5KTtcbiAgaWYgKHByb3BDb3VudCA+IDEpIHJldHVybiBmYWxzZTtcbiAgaWYgKHByb3BDb3VudCA9PT0gMSkgcmV0dXJuIE9iamVjdC5rZXlzKGlkZW50aXR5KVswXTtcbiAgaWYgKHByb3BDb3VudCA9PT0gMCkgaWYgKFsnc3RyaW5nJywgJ251bWJlciddLmluZGV4T2YoZ2V0VHlwZShpZGVudGl0eSkpID4gLTEpIHJldHVybiBpZGVudGl0eTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgaWRlbnRpdHkgaXMgbm9uLWZhbHN5XHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgY3JpdGVyaWEgbWF0Y2hlZCwgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc1RydXRoeShpZGVudGl0eSkge1xuICByZXR1cm4gIWlzRmFsc3koaWRlbnRpdHkpO1xufVxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgaWRlbnRpdHkgaXMgZmFsc3lcclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBjcml0ZXJpYSBtYXRjaGVkLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRmFsc3koaWRlbnRpdHkpIHtcbiAgaWYgKGZhbHNlcihpZGVudGl0eSkgPT09IGZhbHNlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIGZhbHNlLWxpa2UgdmFsdWVzIGludG8gYWN0dWFsIGJvb2xlYW4gdmFsdWUgb2YgZmFsc2VcclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEByZXR1cm4ge0FueSB8fCBib29sZWFufSBSZXR1cm5zIGZhbHNlIGlzIHZhbHVlIGlzIGZhbHN5LCBvdGhlcndpc2UgcmV0dXJucyBvcmlnaW5hbCB2YWx1ZS5cclxuICovXG5cblxuZnVuY3Rpb24gZmFsc2VyKGlkZW50aXR5KSB7XG4gIGlmIChpc0l0ZXJhYmxlKGlkZW50aXR5KSkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoWydudWxsJywgJ3VuZGVmaW5lZCddLmluZGV4T2YoZ2V0VHlwZShpZGVudGl0eSkpID4gLTEpIHJldHVybiBmYWxzZTtcbiAgaWYgKFsnJywgMCwgZmFsc2VdLmluZGV4T2YoaWRlbnRpdHkpID4gLTEpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlkZW50aXR5O1xufVxuLyoqXHJcbiAqIENoZWNrIHRoZSBsZW5ndGggb2YgdGhlIHRvcC1tb3N0IGRlcHRoIG9mIHRoZSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHJldHVybiB7aW50ZWdlcn0gR3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aChpZGVudGl0eSkge1xuICBpZiAoWydhcnJheScsICdvYmplY3QnXS5pbmRleE9mKGdldFR5cGUoaWRlbnRpdHkpKSA9PT0gLTEpIHJldHVybiAwO1xuICByZXR1cm4gT2JqZWN0LmtleXMoaWRlbnRpdHkpLmxlbmd0aDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBmb3IgZWFjaCBpZGVudGl0eSBvbiBjb2xsZWN0aW9uLCB0byBzaG9ydGVuIHRoZSBpZGVudGl0aWVzIHRvIHRob3NlIHRoYXQgZG9lcyBtZWV0cyB0aGUgbWF0Y2ggY3JpdGVyaWFcclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXRpZXNcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge0FueX0gUmV0dXJucyBhIGNvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgJ2lkZW50aXRpZXMnIHBhcmFtZXRlciBwcm92aWRlZCB3aXRoIG9ubHkgdGhlIGlkZW50aXRpZXMgdGhhdCB3ZXJlIG5vdCBtYXRjaGVkLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5TWlzc2luZyhjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgaWYgKGdldFR5cGUoaWRlbnRpdGllcykgPT09ICdhcnJheScpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWRlbnRpdGllcy5mb3JFYWNoKGlkZW50aXR5ID0+IHtcbiAgICAgIGlmICghZXhpc3RzKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkpIHJlc3VsdC5wdXNoKGlkZW50aXR5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGdldFR5cGUoaWRlbnRpdGllcykgPT09ICdvYmplY3QnKSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGlkZW50aXRpZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGxldCBpZGVudGl0eSA9IGlkZW50aXRpZXNba2V5XTtcbiAgICAgIGlmICghZXhpc3RzKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkpIHJlc3VsdFtrZXldID0gaWRlbnRpdHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghZXhpc3RzKGNvbGxlY3Rpb24sIGlkZW50aXRpZXMsIG1heERlcHRoKSkgcmV0dXJuIGlkZW50aXRpZXM7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggZm9yIGVhY2ggaWRlbnRpdHkgb24gY29sbGVjdGlvbiwgdG8gc2hvcnRlbiB0aGUgaWRlbnRpdGllcyB0byB0aG9zZSB0aGF0IG1lZXRzIHRoZSBtYXRjaCBjcml0ZXJpYVxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdGllc1xyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QW55fSBSZXR1cm5zIGEgY29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSAnaWRlbnRpdGllcycgcGFyYW1ldGVyIHByb3ZpZGVkIHdpdGggb25seSB0aGUgaWRlbnRpdGllcyB0aGF0IG1hdGNoZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlFeGlzdGluZyhjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgaWYgKGdldFR5cGUoaWRlbnRpdGllcykgPT09ICdhcnJheScpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWRlbnRpdGllcy5mb3JFYWNoKGlkZW50aXR5ID0+IHtcbiAgICAgIGlmIChleGlzdHMoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKSkgcmVzdWx0LnB1c2goaWRlbnRpdHkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoZ2V0VHlwZShpZGVudGl0aWVzKSA9PT0gJ29iamVjdCcpIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMoaWRlbnRpdGllcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgbGV0IGlkZW50aXR5ID0gaWRlbnRpdGllc1trZXldO1xuICAgICAgaWYgKGV4aXN0cyhjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpKSByZXN1bHRba2V5XSA9IGlkZW50aXR5O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoZXhpc3RzKGNvbGxlY3Rpb24sIGlkZW50aXRpZXMsIG1heERlcHRoKSkgcmV0dXJuIGlkZW50aXRpZXM7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGFueSBtYXRjaCB0byB0aGUgaWRlbnRpdHlcclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiBhIG1hdGNoIGlzIGNvbmZpcm1lZCB3aWxsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgZmFsc2VcclxuICovXG5cblxuZnVuY3Rpb24gZXhpc3RzKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCA9IG51bGwsIGN1cnJlbnREZXB0aCA9IDApIHtcbiAgaWYgKGlkZW50aWNhbChjb2xsZWN0aW9uLCBpZGVudGl0eSkpIHJldHVybiB0cnVlO1xuICBpZiAoaXNJdGVyYWJsZShpZGVudGl0eSkpIGlmIChzYW1lVHlwZShjb2xsZWN0aW9uLCBpZGVudGl0eSkpIGlmIChjb250YWluc0tleXMoY29sbGVjdGlvbiwgT2JqZWN0LmtleXMoaWRlbnRpdHkpKSkge1xuICAgIGNvbnN0IHRyaW1tZWQgPSB0cmltKGNvbGxlY3Rpb24sIE9iamVjdC5rZXlzKGlkZW50aXR5KSk7XG4gICAgaWYgKGlkZW50aWNhbCh0cmltbWVkLCBpZGVudGl0eSkpIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChtYXhEZXB0aCA9PT0gbnVsbCA/IHRydWUgOiBjdXJyZW50RGVwdGggPCBtYXhEZXB0aCkgaWYgKGlzSXRlcmFibGUoY29sbGVjdGlvbikpIGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbiksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgc3ViY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25ba2V5XSxcbiAgICAgICAgICByZXMgPSBleGlzdHMoc3ViY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICBpZiAocmVzKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGFsbCBtYXRjaGVzIHRvIHRoZSBpZGVudGl0eSwgd2lsbCByZXR1cm4gYSBsaXN0IG9mIGlkZW50aXRpZXMgY29udGFpbmluZyB0aGUgbWF0Y2guIElmIG5vIG1hdGNoZXMgZm91bmQsIGl0IHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QXJyYXkgfHwgdW5kZWZpbmVkfSBpZGVudGl0aWVzXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBGaWx0ZXIoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCkge1xuICB2YXIgcGF0aHMgPSBsb2NhdGVBbGwoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKTtcbiAgaWYgKHBhdGhzID09PSBmYWxzZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgY29uc3QgcmVzdWx0cyA9IHBhdGhzLm1hcChwYXRoID0+IHtcbiAgICBpZiAocGF0aCA9PT0gJycpIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgaWYgKFsnYXJyYXknLCAnb2JqZWN0J10uaW5kZXhPZihnZXRUeXBlKGlkZW50aXR5KSkgPT09IC0xKSBwYXRoLnNwbGljZSgtMSwgMSk7XG4gICAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb247XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKSByZXR1cm4gcmVzdWx0W3BhdGhdO1xuICAgIHBhdGguZm9yRWFjaChrZXkgPT4ge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0W2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIG9uIGNvbGxlY3Rpb24gdG8gZmluZCBhbGwgbWF0Y2hlcyB0byB0aGUgaWRlbnRpdHksIHJldHVybnMgYSBzdHJpbmcgYXJyYXkgY29udGFpbmluZyB0aGUgbG9jYXRpb24gb2YgYWxsIG1hdGNoZXMuIElmIG5vIG1hdGNoZXMgZm91bmQsIGl0IHJldHVybnMgYGZhbHNlYC5cclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtBcnJheSB8fCBmYWxzZX0gUGF0aHNcclxuICovXG5cblxuZnVuY3Rpb24gbG9jYXRlQWxsKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgdmFyIFIgPSBbXTtcblxuICBmdW5jdGlvbiBfbG9jYXRlQWxsKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBwYXRoID0gJycsIG1heERlcHRoLCBjdXJyZW50RGVwdGgpIHtcbiAgICBpZiAoaXNJdGVyYWJsZShpZGVudGl0eSkpIGlmIChzYW1lVHlwZShjb2xsZWN0aW9uLCBpZGVudGl0eSkpIGlmIChjb250YWluc0tleXMoY29sbGVjdGlvbiwgT2JqZWN0LmtleXMoaWRlbnRpdHkpKSkge1xuICAgICAgY29uc3QgdHJpbW1lZCA9IHRyaW0oY29sbGVjdGlvbiwgT2JqZWN0LmtleXMoaWRlbnRpdHkpKTtcbiAgICAgIGlmIChpZGVudGljYWwodHJpbW1lZCwgaWRlbnRpdHkpKSBSW1IubGVuZ3RoXSA9IHBhdGg7XG4gICAgfVxuICAgIGlmIChpZGVudGljYWwoY29sbGVjdGlvbiwgaWRlbnRpdHkpKSBSW1IubGVuZ3RoXSA9IHBhdGg7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCkgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoaXNJdGVyYWJsZShjb2xsZWN0aW9uKSkgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgc3ViY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25ba2V5XTtcblxuICAgICAgX2xvY2F0ZUFsbChzdWJjb2xsZWN0aW9uLCBpZGVudGl0eSwgKHBhdGggPT09ICcnID8gcGF0aCA6IHBhdGggKyAnLicpICsga2V5LCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG4gICAgfVxuICB9XG5cbiAgX2xvY2F0ZUFsbChjb2xsZWN0aW9uLCBpZGVudGl0eSwgJycsIG1heERlcHRoLCAwKTtcblxuICByZXR1cm4gUi5sZW5ndGggPT09IDAgPyBmYWxzZSA6IFI7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGEgbWF0Y2ggdG8gdGhlIGlkZW50aXR5LCB3aWxsIHJldHVybiB0aGUgaWRlbnRpdHkgY29udGFpbmluZyBvZiB0aGUgZmlyc3QgaW5zdGFuY2UgbWF0Y2hlZC4gSWYgbm8gbWF0Y2hlcyBmb3VuZCwgaXQgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtpZGVudGl0eSB8fCB1bmRlZmluZWR9IGlkZW50aXR5XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBHZXQoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCkge1xuICB2YXIgcGF0aCA9IGxvY2F0ZShjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpO1xuICBpZiAocGF0aCA9PT0gZmFsc2UpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChwYXRoID09PSAnJykgcmV0dXJuIGNvbGxlY3Rpb247XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGlmIChbJ2FycmF5JywgJ29iamVjdCddLmluZGV4T2YoZ2V0VHlwZShpZGVudGl0eSkpID09PSAtMSkgcGF0aC5zcGxpY2UoLTEsIDEpO1xuICB2YXIgcmVzdWx0ID0gY29sbGVjdGlvbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKSByZXR1cm4gcmVzdWx0W3BhdGhdO1xuICBwYXRoLmZvckVhY2goa2V5ID0+IHtcbiAgICByZXN1bHQgPSByZXN1bHRba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGEgbWF0Y2ggdG8gdGhlIGlkZW50aXR5LCB3aWxsIHJldHVybiB0aGUgcGF0aCBvZiB0aGUgZmlyc3QgaW5zdGFuY2UgbWF0Y2hlZCBhcyBzdHJpbmcuIElmIG5vIG1hdGNoZXMgZm91bmQsIHJldHVybnMgYGZhbHNlYC5cclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgbnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtzdHJpbmcgfHwgZmFsc2V9IHBhdGhcclxuICovXG5cblxuZnVuY3Rpb24gbG9jYXRlKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgZnVuY3Rpb24gX2xvY2F0ZShjb2xsZWN0aW9uLCBpZGVudGl0eSwgcGF0aCA9ICcnLCBtYXhEZXB0aCwgY3VycmVudERlcHRoKSB7XG4gICAgaWYgKGlzSXRlcmFibGUoaWRlbnRpdHkpKSBpZiAoc2FtZVR5cGUoY29sbGVjdGlvbiwgaWRlbnRpdHkpKSBpZiAoY29udGFpbnNLZXlzKGNvbGxlY3Rpb24sIE9iamVjdC5rZXlzKGlkZW50aXR5KSkpIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSB0cmltKGNvbGxlY3Rpb24sIE9iamVjdC5rZXlzKGlkZW50aXR5KSk7XG4gICAgICBpZiAoaWRlbnRpY2FsKHRyaW1tZWQsIGlkZW50aXR5KSkgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGlmIChpZGVudGljYWwoY29sbGVjdGlvbiwgaWRlbnRpdHkpKSByZXR1cm4gcGF0aDtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKG1heERlcHRoICE9PSBudWxsKSBpZiAoY3VycmVudERlcHRoID49IG1heERlcHRoKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChpc0l0ZXJhYmxlKGNvbGxlY3Rpb24pKSBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICBzdWJjb2xsZWN0aW9uID0gY29sbGVjdGlvbltrZXldLFxuICAgICAgICAgICAgcmVzID0gX2xvY2F0ZShzdWJjb2xsZWN0aW9uLCBpZGVudGl0eSwga2V5LCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG5cbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgcGF0aCA9IHBhdGggPT09ICcnID8gcGF0aCA6IHBhdGggKyAnLic7XG4gICAgICAgIHJlc3VsdCA9IHBhdGggKyByZXM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIF9sb2NhdGUoY29sbGVjdGlvbiwgaWRlbnRpdHksICcnLCBtYXhEZXB0aCwgMCk7XG59XG4vKipcclxuICogVHJpbXMgYW4gaWRlbnRpdHkgdG8gb25seSBjb250YWluIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7QW55fSBrZXlMaXN0XHJcbiAqIEByZXR1cm4ge09iamVjdCBvciBBcnJheX0gUmV0dXJucyAsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmltKGlkZW50aXR5LCBrZXlMaXN0KSB7XG4gIGNvbnN0IGlkZW50aXR5VHlwZSA9IGdldFR5cGUoaWRlbnRpdHkpO1xuICBpZiAoWydhcnJheScsICdvYmplY3QnXS5pbmRleE9mKGlkZW50aXR5VHlwZSkgPT09IC0xKSByZXR1cm4gdW5kZWZpbmVkO1xuICBjb25zdCBrZXlDb3VudCA9IGtleUxpc3QubGVuZ3RoO1xuICBpZiAoa2V5Q291bnQgPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG4gIHZhciBuZXdJZGVudGl0eTtcblxuICBzd2l0Y2ggKGlkZW50aXR5VHlwZSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBuZXdJZGVudGl0eSA9IHt9O1xuICAgICAga2V5TGlzdC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChrZXkgaW4gaWRlbnRpdHkpIG5ld0lkZW50aXR5W2tleV0gPSBpZGVudGl0eVtrZXldO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIG5ld0lkZW50aXR5ID0gW107XG4gICAgICBrZXlMaXN0LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGtleSBpbiBpZGVudGl0eSkgbmV3SWRlbnRpdHkucHVzaChpZGVudGl0eVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gbmV3SWRlbnRpdHk7XG59XG4vKipcclxuICogQ2hlY2sgaWYgaWRlbnRpdHkgY29udGFpbnMgYWxsIG9mIHRoZSBzcGVjaWZpZWQga2V5c1xyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtBcnJheX0ga2V5TGlzdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIHx8IGZhbHNlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbnRhaW5zS2V5cyhpZGVudGl0eSwga2V5TGlzdCkge1xuICBjb25zdCBrZXlDb3VudCA9IGtleUxpc3QubGVuZ3RoO1xuICBpZiAoa2V5Q291bnQgPT09IDAgfHwgIWlzSXRlcmFibGUoaWRlbnRpdHkpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGlkZW50aXR5a2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5KTtcbiAgdmFyIHJlc3VsdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gJycgKyBrZXlMaXN0W2ldO1xuXG4gICAgaWYgKGlkZW50aXR5a2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcclxuICogQ2hlY2sgaWYgaWRlbnRpdHkgaGFzIG9uZSBvciBtb3JlIGtleXMgdG8gaXRlcmF0ZVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSB8fCBmYWxzZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKGlkZW50aXR5KSB7XG4gIGlmIChbJ2FycmF5JywgJ29iamVjdCddLmluZGV4T2YoZ2V0VHlwZShpZGVudGl0eSkpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoT2JqZWN0LmtleXMoaWRlbnRpdHkpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gaWRlbnRpdGllcywgd2lsbCByZXR1cm4gZWl0aGVyIHRydWUgaWYgaWRlbnRpY2FsLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eUFcclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5QlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIHx8IGZhbHNlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aWNhbChpZGVudGl0eUEsIGlkZW50aXR5Qikge1xuICBjb25zdCBzdHJ1Y3R1cmVNYXRjaCA9IHNhbWVTdHJ1Y3R1cmUoaWRlbnRpdHlBLCBpZGVudGl0eUIpO1xuICBpZiAoc3RydWN0dXJlTWF0Y2ggPT09IGZhbHNlKSByZXR1cm4gc3RydWN0dXJlTWF0Y2g7XG4gIGlmIChbJ2FycmF5JywgJ29iamVjdCddLmluZGV4T2Yoc3RydWN0dXJlTWF0Y2gpID09PSAtMSkgcmV0dXJuIGlkZW50aXR5QSA9PT0gaWRlbnRpdHlCO1xuICBjb25zdCBLZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHlBKSxcbiAgICAgICAgS2V5Q291bnQgPSBLZXlzLmxlbmd0aDtcbiAgdmFyIGNoaWxkTWF0Y2ggPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgS2V5Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IEtleSA9IEtleXNbaV0sXG4gICAgICAgICAgaWRlbnRpY2FsTWF0Y2ggPSBpZGVudGljYWwoaWRlbnRpdHlBW0tleV0sIGlkZW50aXR5QltLZXldKTtcblxuICAgIGlmIChpZGVudGljYWxNYXRjaCA9PT0gZmFsc2UpIHtcbiAgICAgIGNoaWxkTWF0Y2ggPSBpZGVudGljYWxNYXRjaDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIDtcbiAgfVxuXG4gIHJldHVybiBjaGlsZE1hdGNoO1xufVxuLyoqXHJcbiAqIENvbXBhcmVzIGRhdGEgc3RydWN0dXJlIG9mIHR3byBpZGVudGl0aWVzLCB3aWxsIHJldHVybiBlaXRoZXIgdGhlIGRhdGFUeXBlIG9yIHRydWUvZmFsc2UuXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eUFcclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5QlxyXG4gKiBAcmV0dXJuIHtTdHJpbmcgfHwgRmFsc2V9IERhdGFUeXBlIGFzIHN0cmluZyBmb3IgcG9zaXRpdmUgbWF0Y2gsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzYW1lU3RydWN0dXJlKGlkZW50aXR5QSwgaWRlbnRpdHlCKSB7XG4gIGNvbnN0IHR5cGVNYXRjaCA9IHNhbWVUeXBlKGlkZW50aXR5QSwgaWRlbnRpdHlCKTtcbiAgaWYgKHR5cGVNYXRjaCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICBpZiAoWydhcnJheScsICdvYmplY3QnXS5pbmRleE9mKHR5cGVNYXRjaCkgPiAtMSkge1xuICAgIGNvbnN0IEFLZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHlBKSxcbiAgICAgICAgICBCS2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5QiksXG4gICAgICAgICAgQUtleUNvdW50ID0gQUtleXMubGVuZ3RoLFxuICAgICAgICAgIEJLZXlDb3VudCA9IEJLZXlzLmxlbmd0aDtcbiAgICBpZiAoIShBS2V5Q291bnQgPT09IEJLZXlDb3VudCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQUtleUNvdW50ID09PSAwKSByZXR1cm4gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQUtleUNvdW50OyBpKyspIHtcbiAgICAgIGlmIChBS2V5c1tpXSAhPT0gQktleXNbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHlwZU1hdGNoO1xufVxuLyoqXHJcbiAqIENvbXBhcmVzIGRhdGEgdHlwZSBvZiB0d28gaWRlbnRpdGllcywgd2lsbCBkYXRhVHlwZSBpZiB0cnVlLlxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlBXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eUJcclxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSB8fCBmYWxzZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzYW1lVHlwZShpZGVudGl0eUEsIGlkZW50aXR5Qikge1xuICBjb25zdCB0eXBlQSA9IGdldFR5cGUoaWRlbnRpdHlBKTtcbiAgcmV0dXJuIHR5cGVBID09PSBnZXRUeXBlKGlkZW50aXR5QikgPyB0eXBlQSA6IGZhbHNlO1xufVxuLyoqXHJcbiAqIEdldHMgZGF0YSB0eXBlOyBtYWtlcyBkaXN0aW50aW9uIGJldHdlZW4gb2JqZWN0LCBhcnJheSwgYW5kIG51bGwuXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGFUeXBlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFR5cGUoaWRlbnRpdHkpIHtcbiAgaWYgKGlkZW50aXR5ID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBjb25zdCBpdCA9IHR5cGVvZiBpZGVudGl0eTtcbiAgaWYgKGl0ID09PSAnb2JqZWN0JykgaWYgKEFycmF5LmlzQXJyYXkoaWRlbnRpdHkpKSByZXR1cm4gJ2FycmF5JztcbiAgcmV0dXJuIGl0O1xufVxuXG52YXIgbWl0c3VrZXRhID0ge1xuICBnZXRUeXBlOiBmdW5jdGlvbiAoaWRlbnRpdHkpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShpZGVudGl0eSk7XG4gIH0sXG4gIHNhbWVUeXBlOiBmdW5jdGlvbiAoaWRlbnRpdHlBLCBpZGVudGl0eUIpIHtcbiAgICByZXR1cm4gc2FtZVR5cGUoaWRlbnRpdHlBLCBpZGVudGl0eUIpO1xuICB9LFxuICBzYW1lU3RydWN0dXJlOiBmdW5jdGlvbiAoaWRlbnRpdHlBLCBpZGVudGl0eUIpIHtcbiAgICByZXR1cm4gc2FtZVN0cnVjdHVyZShpZGVudGl0eUEsIGlkZW50aXR5Qik7XG4gIH0sXG4gIGlkZW50aWNhbDogZnVuY3Rpb24gKGlkZW50aXR5QSwgaWRlbnRpdHlCKSB7XG4gICAgcmV0dXJuIGlkZW50aWNhbChpZGVudGl0eUEsIGlkZW50aXR5Qik7XG4gIH0sXG4gIGlzSXRlcmFibGU6IGZ1bmN0aW9uIChpZGVudGl0eSkge1xuICAgIHJldHVybiBpc0l0ZXJhYmxlKGlkZW50aXR5KTtcbiAgfSxcbiAgY29udGFpbnNLZXlzOiBmdW5jdGlvbiAoaWRlbnRpdHksIGtleUxpc3QpIHtcbiAgICByZXR1cm4gY29udGFpbnNLZXlzKGlkZW50aXR5LCBrZXlMaXN0KTtcbiAgfSxcbiAgdHJpbTogZnVuY3Rpb24gKGlkZW50aXR5LCBrZXlMaXN0KSB7XG4gICAgcmV0dXJuIHRyaW0oaWRlbnRpdHksIGtleUxpc3QpO1xuICB9LFxuICBsb2NhdGU6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gbG9jYXRlKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIH0sXG4gIGRlZXBHZXQ6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gZGVlcEdldChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpO1xuICB9LFxuICBsb2NhdGVBbGw6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gbG9jYXRlQWxsKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIH0sXG4gIGRlZXBGaWx0ZXI6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gZGVlcEZpbHRlcihjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpO1xuICB9LFxuICBleGlzdHM6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gZXhpc3RzKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIH0sXG4gIG9ubHlFeGlzdGluZzogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXRpZXMsIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIG9ubHlFeGlzdGluZyhjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBtYXhEZXB0aCk7XG4gIH0sXG4gIG9ubHlNaXNzaW5nOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gb25seU1pc3NpbmcoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgbWF4RGVwdGgpO1xuICB9LFxuICBsZW5ndGg6IGZ1bmN0aW9uIChpZGVudGl0eSkge1xuICAgIHJldHVybiBsZW5ndGgoaWRlbnRpdHkpO1xuICB9LFxuICBpc0ZhbHN5OiBmdW5jdGlvbiAoaWRlbnRpdHkpIHtcbiAgICByZXR1cm4gaXNGYWxzeShpZGVudGl0eSk7XG4gIH0sXG4gIGlzVHJ1dGh5OiBmdW5jdGlvbiAoaWRlbnRpdHkpIHtcbiAgICByZXR1cm4gaXNUcnV0aHkoaWRlbnRpdHkpO1xuICB9LFxuICBmb3VuZFRydXRoeTogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBmb3VuZFRydXRoeShjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpO1xuICB9LFxuICBvbmx5VHJ1dGh5OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgcHJvcGVydHksIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIG9ubHlUcnV0aHkoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgcHJvcGVydHksIG1heERlcHRoKTtcbiAgfSxcbiAgZm91bmRGYWxzeTogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBmb3VuZEZhbHN5KGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIH0sXG4gIG9ubHlGYWxzeTogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXRpZXMsIHByb3BlcnR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBvbmx5RmFsc3koY29sbGVjdGlvbiwgaWRlbnRpdGllcywgcHJvcGVydHksIG1heERlcHRoKTtcbiAgfSxcbiAgY291bnRNYXRjaGVzOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWRlbnRpdHksIG50aERlcHRoLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBjb3VudE1hdGNoZXMoY29sbGVjdGlvbiwgaWRlbnRpdHksIG50aERlcHRoLCBtYXhEZXB0aCk7XG4gIH0sXG4gIG1hdGNoRGVwdGg6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gbWF0Y2hEZXB0aChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpO1xuICB9LFxuICBtYXhEZXB0aDogZnVuY3Rpb24gKGlkZW50aXR5LCBtYXhMYXllcikge1xuICAgIHJldHVybiBtYXhEZXB0aChpZGVudGl0eSwgbWF4TGF5ZXIpO1xuICB9LFxuICBsb2NhdGVfS2V5OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gbG9jYXRlX0tleShjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCk7XG4gIH0sXG4gIGRlZXBHZXRfS2V5OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gZGVlcEdldF9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGgpO1xuICB9LFxuICBsb2NhdGVBbGxfS2V5OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gbG9jYXRlQWxsX0tleShjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCk7XG4gIH0sXG4gIGRlZXBGaWx0ZXJfS2V5OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gZGVlcEZpbHRlcl9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGgpO1xuICB9LFxuICBkZWVwQ2xvbmU6IGZ1bmN0aW9uIChpZGVudGl0eSwgbWF4RGVwdGgsIHN0YXJ0RGVwdGgpIHtcbiAgICByZXR1cm4gZGVlcENsb25lKGlkZW50aXR5LCBtYXhEZXB0aCwgc3RhcnREZXB0aCk7XG4gIH0sXG4gIHJlbmFtZUtleTogZnVuY3Rpb24gKGlkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiByZW5hbWVLZXkoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoKTtcbiAgfSxcbiAgcmVuYW1lS2V5czogZnVuY3Rpb24gKGlkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiByZW5hbWVLZXlzKGlkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCk7XG4gIH0sXG4gIGRlZXBSZW1vdmVfS2V5OiBmdW5jdGlvbiAoaWRlbnRpdHksIGtleU5hbWUsIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIGRlZXBSZW1vdmVfS2V5KGlkZW50aXR5LCBrZXlOYW1lLCBtYXhEZXB0aCk7XG4gIH0sXG4gIGRlZXBSZW1vdmVBbGxfS2V5OiBmdW5jdGlvbiAoaWRlbnRpdHksIGtleU5hbWUsIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIGRlZXBSZW1vdmVBbGxfS2V5KGlkZW50aXR5LCBrZXlOYW1lLCBtYXhEZXB0aCk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBtaXRzdWtldGE7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js\n");

/***/ }),

/***/ "./node_modules/react-json-editor-ajrm/es/themes.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/themes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst dark_vscode_tribute = {\n  default: '#D4D4D4',\n  background: '#1E1E1E',\n  background_warning: '#1E1E1E',\n  string: '#CE8453',\n  number: '#B5CE9F',\n  colon: '#49B8F7',\n  keys: '#9CDCFE',\n  keys_whiteSpace: '#AF74A5',\n  primitive: '#6392C6'\n};\nconst light_mitsuketa_tribute = {\n  default: '#D4D4D4',\n  background: '#FCFDFD',\n  background_warning: '#FEECEB',\n  string: '#FA7921',\n  number: '#70CE35',\n  colon: '#49B8F7',\n  keys: '#59A5D8',\n  keys_whiteSpace: '#835FB6',\n  primitive: '#386FA4'\n};\nconst themes = {\n  dark_vscode_tribute: dark_vscode_tribute,\n  light_mitsuketa_tribute: light_mitsuketa_tribute\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (themes);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy90aGVtZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9lcy90aGVtZXMuanM/ODBlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkYXJrX3ZzY29kZV90cmlidXRlID0ge1xuICBkZWZhdWx0OiAnI0Q0RDRENCcsXG4gIGJhY2tncm91bmQ6ICcjMUUxRTFFJyxcbiAgYmFja2dyb3VuZF93YXJuaW5nOiAnIzFFMUUxRScsXG4gIHN0cmluZzogJyNDRTg0NTMnLFxuICBudW1iZXI6ICcjQjVDRTlGJyxcbiAgY29sb246ICcjNDlCOEY3JyxcbiAga2V5czogJyM5Q0RDRkUnLFxuICBrZXlzX3doaXRlU3BhY2U6ICcjQUY3NEE1JyxcbiAgcHJpbWl0aXZlOiAnIzYzOTJDNidcbn07XG5jb25zdCBsaWdodF9taXRzdWtldGFfdHJpYnV0ZSA9IHtcbiAgZGVmYXVsdDogJyNENEQ0RDQnLFxuICBiYWNrZ3JvdW5kOiAnI0ZDRkRGRCcsXG4gIGJhY2tncm91bmRfd2FybmluZzogJyNGRUVDRUInLFxuICBzdHJpbmc6ICcjRkE3OTIxJyxcbiAgbnVtYmVyOiAnIzcwQ0UzNScsXG4gIGNvbG9uOiAnIzQ5QjhGNycsXG4gIGtleXM6ICcjNTlBNUQ4JyxcbiAga2V5c193aGl0ZVNwYWNlOiAnIzgzNUZCNicsXG4gIHByaW1pdGl2ZTogJyMzODZGQTQnXG59O1xuY29uc3QgdGhlbWVzID0ge1xuICBkYXJrX3ZzY29kZV90cmlidXRlOiBkYXJrX3ZzY29kZV90cmlidXRlLFxuICBsaWdodF9taXRzdWtldGFfdHJpYnV0ZTogbGlnaHRfbWl0c3VrZXRhX3RyaWJ1dGVcbn07XG5leHBvcnQgZGVmYXVsdCB0aGVtZXM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/es/themes.js\n");

/***/ }),

/***/ "./node_modules/react-json-editor-ajrm/locale/en.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/locale/en.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  format: \"{reason} at line {line}\",\n  symbols: {\n    colon: \"colon\",\n    // :\n    comma: \"comma\",\n    // ,  ،  、\n    semicolon: \"semicolon\",\n    // ;\n    slash: \"slash\",\n    // /  relevant for comment syntax support\n    backslash: \"backslash\",\n    // \\  relevant for escaping character\n    brackets: {\n      round: \"round brackets\",\n      // ( )\n      square: \"square brackets\",\n      // [ ]\n      curly: \"curly brackets\",\n      // { }\n      angle: \"angle brackets\" // < >\n\n    },\n    period: \"period\",\n    // . Also known as full point, full stop, or dot\n    quotes: {\n      single: \"single quote\",\n      // '\n      double: \"double quote\",\n      // \"\n      grave: \"grave accent\" // ` used on Javascript ES6 Syntax for String Templates\n\n    },\n    space: \"space\",\n    //       \n    ampersand: \"ampersand\",\n    //\t&\n    asterisk: \"asterisk\",\n    //\t*  relevant for some comment sytanx\n    at: \"at sign\",\n    //\t@  multiple uses in other coding languages including certain data types\n    equals: \"equals sign\",\n    //\t=\n    hash: \"hash\",\n    //\t#\n    percent: \"percent\",\n    //\t%\n    plus: \"plus\",\n    //\t+\n    minus: \"minus\",\n    //\t−\n    dash: \"dash\",\n    //\t−\n    hyphen: \"hyphen\",\n    //\t−\n    tilde: \"tilde\",\n    //\t~\n    underscore: \"underscore\",\n    //\t_\n    bar: \"vertical bar\" //\t|\n\n  },\n  types: {\n    key: \"key\",\n    value: \"value\",\n    number: \"number\",\n    string: \"string\",\n    primitive: \"primitive\",\n    boolean: \"boolean\",\n    character: \"character\",\n    integer: \"integer\",\n    array: \"array\",\n    float: \"float\" //... Reference: https://en.wikipedia.org/wiki/List_of_data_structures\n\n  },\n  invalidToken: {\n    tokenSequence: {\n      prohibited: \"'{firstToken}' token cannot be followed by '{secondToken}' token(s)\",\n      permitted: \"'{firstToken}' token can only be followed by '{secondToken}' token(s)\"\n    },\n    termSequence: {\n      prohibited: \"A {firstTerm} cannot be followed by a {secondTerm}\",\n      permitted: \"A {firstTerm} can only be followed by a {secondTerm}\"\n    },\n    double: \"'{token}' token cannot be followed by another '{token}' token\",\n    useInstead: \"'{badToken}' token is not accepted. Use '{goodToken}' instead\",\n    unexpected: \"Unexpected '{token}' token found\"\n  },\n  brace: {\n    curly: {\n      missingOpen: \"Missing '{' open curly brace\",\n      missingClose: \"Open '{' curly brace is missing closing '}' curly brace\",\n      cannotWrap: \"'{token}' token cannot be wrapped in '{}' curly braces\"\n    },\n    square: {\n      missingOpen: \"Missing '[' open square brace\",\n      missingClose: \"Open '[' square brace is missing closing ']' square brace\",\n      cannotWrap: \"'{token}' token cannot be wrapped in '[]' square braces\"\n    }\n  },\n  string: {\n    missingOpen: \"Missing/invalid opening string '{quote}' token\",\n    missingClose: \"Missing/invalid closing string '{quote}' token\",\n    mustBeWrappedByQuotes: \"Strings must be wrapped by quotes\",\n    nonAlphanumeric: \"Non-alphanumeric token '{token}' is not allowed outside string notation\",\n    unexpectedKey: \"Unexpected key found at string position\"\n  },\n  key: {\n    numberAndLetterMissingQuotes: \"Key beginning with number and containing letters must be wrapped by quotes\",\n    spaceMissingQuotes: \"Key containing space must be wrapped by quotes\",\n    unexpectedString: \"Unexpected string found at key position\"\n  },\n  noTrailingOrLeadingComma: \"Trailing or leading commas in arrays and objects are not permitted\"\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9sb2NhbGUvZW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9sb2NhbGUvZW4uanM/MWI2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9IHtcbiAgZm9ybWF0OiBcIntyZWFzb259IGF0IGxpbmUge2xpbmV9XCIsXG4gIHN5bWJvbHM6IHtcbiAgICBjb2xvbjogXCJjb2xvblwiLFxuICAgIC8vIDpcbiAgICBjb21tYTogXCJjb21tYVwiLFxuICAgIC8vICwgINiMICDjgIFcbiAgICBzZW1pY29sb246IFwic2VtaWNvbG9uXCIsXG4gICAgLy8gO1xuICAgIHNsYXNoOiBcInNsYXNoXCIsXG4gICAgLy8gLyAgcmVsZXZhbnQgZm9yIGNvbW1lbnQgc3ludGF4IHN1cHBvcnRcbiAgICBiYWNrc2xhc2g6IFwiYmFja3NsYXNoXCIsXG4gICAgLy8gXFwgIHJlbGV2YW50IGZvciBlc2NhcGluZyBjaGFyYWN0ZXJcbiAgICBicmFja2V0czoge1xuICAgICAgcm91bmQ6IFwicm91bmQgYnJhY2tldHNcIixcbiAgICAgIC8vICggKVxuICAgICAgc3F1YXJlOiBcInNxdWFyZSBicmFja2V0c1wiLFxuICAgICAgLy8gWyBdXG4gICAgICBjdXJseTogXCJjdXJseSBicmFja2V0c1wiLFxuICAgICAgLy8geyB9XG4gICAgICBhbmdsZTogXCJhbmdsZSBicmFja2V0c1wiIC8vIDwgPlxuXG4gICAgfSxcbiAgICBwZXJpb2Q6IFwicGVyaW9kXCIsXG4gICAgLy8gLiBBbHNvIGtub3duIGFzIGZ1bGwgcG9pbnQsIGZ1bGwgc3RvcCwgb3IgZG90XG4gICAgcXVvdGVzOiB7XG4gICAgICBzaW5nbGU6IFwic2luZ2xlIHF1b3RlXCIsXG4gICAgICAvLyAnXG4gICAgICBkb3VibGU6IFwiZG91YmxlIHF1b3RlXCIsXG4gICAgICAvLyBcIlxuICAgICAgZ3JhdmU6IFwiZ3JhdmUgYWNjZW50XCIgLy8gYCB1c2VkIG9uIEphdmFzY3JpcHQgRVM2IFN5bnRheCBmb3IgU3RyaW5nIFRlbXBsYXRlc1xuXG4gICAgfSxcbiAgICBzcGFjZTogXCJzcGFjZVwiLFxuICAgIC8vICAg4oCCICDigINcbiAgICBhbXBlcnNhbmQ6IFwiYW1wZXJzYW5kXCIsXG4gICAgLy9cdCZcbiAgICBhc3RlcmlzazogXCJhc3Rlcmlza1wiLFxuICAgIC8vXHQqICByZWxldmFudCBmb3Igc29tZSBjb21tZW50IHN5dGFueFxuICAgIGF0OiBcImF0IHNpZ25cIixcbiAgICAvL1x0QCAgbXVsdGlwbGUgdXNlcyBpbiBvdGhlciBjb2RpbmcgbGFuZ3VhZ2VzIGluY2x1ZGluZyBjZXJ0YWluIGRhdGEgdHlwZXNcbiAgICBlcXVhbHM6IFwiZXF1YWxzIHNpZ25cIixcbiAgICAvL1x0PVxuICAgIGhhc2g6IFwiaGFzaFwiLFxuICAgIC8vXHQjXG4gICAgcGVyY2VudDogXCJwZXJjZW50XCIsXG4gICAgLy9cdCVcbiAgICBwbHVzOiBcInBsdXNcIixcbiAgICAvL1x0K1xuICAgIG1pbnVzOiBcIm1pbnVzXCIsXG4gICAgLy9cdOKIklxuICAgIGRhc2g6IFwiZGFzaFwiLFxuICAgIC8vXHTiiJJcbiAgICBoeXBoZW46IFwiaHlwaGVuXCIsXG4gICAgLy9cdOKIklxuICAgIHRpbGRlOiBcInRpbGRlXCIsXG4gICAgLy9cdH5cbiAgICB1bmRlcnNjb3JlOiBcInVuZGVyc2NvcmVcIixcbiAgICAvL1x0X1xuICAgIGJhcjogXCJ2ZXJ0aWNhbCBiYXJcIiAvL1x0fFxuXG4gIH0sXG4gIHR5cGVzOiB7XG4gICAga2V5OiBcImtleVwiLFxuICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgbnVtYmVyOiBcIm51bWJlclwiLFxuICAgIHN0cmluZzogXCJzdHJpbmdcIixcbiAgICBwcmltaXRpdmU6IFwicHJpbWl0aXZlXCIsXG4gICAgYm9vbGVhbjogXCJib29sZWFuXCIsXG4gICAgY2hhcmFjdGVyOiBcImNoYXJhY3RlclwiLFxuICAgIGludGVnZXI6IFwiaW50ZWdlclwiLFxuICAgIGFycmF5OiBcImFycmF5XCIsXG4gICAgZmxvYXQ6IFwiZmxvYXRcIiAvLy4uLiBSZWZlcmVuY2U6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfZGF0YV9zdHJ1Y3R1cmVzXG5cbiAgfSxcbiAgaW52YWxpZFRva2VuOiB7XG4gICAgdG9rZW5TZXF1ZW5jZToge1xuICAgICAgcHJvaGliaXRlZDogXCIne2ZpcnN0VG9rZW59JyB0b2tlbiBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgJ3tzZWNvbmRUb2tlbn0nIHRva2VuKHMpXCIsXG4gICAgICBwZXJtaXR0ZWQ6IFwiJ3tmaXJzdFRva2VufScgdG9rZW4gY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgJ3tzZWNvbmRUb2tlbn0nIHRva2VuKHMpXCJcbiAgICB9LFxuICAgIHRlcm1TZXF1ZW5jZToge1xuICAgICAgcHJvaGliaXRlZDogXCJBIHtmaXJzdFRlcm19IGNhbm5vdCBiZSBmb2xsb3dlZCBieSBhIHtzZWNvbmRUZXJtfVwiLFxuICAgICAgcGVybWl0dGVkOiBcIkEge2ZpcnN0VGVybX0gY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgYSB7c2Vjb25kVGVybX1cIlxuICAgIH0sXG4gICAgZG91YmxlOiBcIid7dG9rZW59JyB0b2tlbiBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgYW5vdGhlciAne3Rva2VufScgdG9rZW5cIixcbiAgICB1c2VJbnN0ZWFkOiBcIid7YmFkVG9rZW59JyB0b2tlbiBpcyBub3QgYWNjZXB0ZWQuIFVzZSAne2dvb2RUb2tlbn0nIGluc3RlYWRcIixcbiAgICB1bmV4cGVjdGVkOiBcIlVuZXhwZWN0ZWQgJ3t0b2tlbn0nIHRva2VuIGZvdW5kXCJcbiAgfSxcbiAgYnJhY2U6IHtcbiAgICBjdXJseToge1xuICAgICAgbWlzc2luZ09wZW46IFwiTWlzc2luZyAneycgb3BlbiBjdXJseSBicmFjZVwiLFxuICAgICAgbWlzc2luZ0Nsb3NlOiBcIk9wZW4gJ3snIGN1cmx5IGJyYWNlIGlzIG1pc3NpbmcgY2xvc2luZyAnfScgY3VybHkgYnJhY2VcIixcbiAgICAgIGNhbm5vdFdyYXA6IFwiJ3t0b2tlbn0nIHRva2VuIGNhbm5vdCBiZSB3cmFwcGVkIGluICd7fScgY3VybHkgYnJhY2VzXCJcbiAgICB9LFxuICAgIHNxdWFyZToge1xuICAgICAgbWlzc2luZ09wZW46IFwiTWlzc2luZyAnWycgb3BlbiBzcXVhcmUgYnJhY2VcIixcbiAgICAgIG1pc3NpbmdDbG9zZTogXCJPcGVuICdbJyBzcXVhcmUgYnJhY2UgaXMgbWlzc2luZyBjbG9zaW5nICddJyBzcXVhcmUgYnJhY2VcIixcbiAgICAgIGNhbm5vdFdyYXA6IFwiJ3t0b2tlbn0nIHRva2VuIGNhbm5vdCBiZSB3cmFwcGVkIGluICdbXScgc3F1YXJlIGJyYWNlc1wiXG4gICAgfVxuICB9LFxuICBzdHJpbmc6IHtcbiAgICBtaXNzaW5nT3BlbjogXCJNaXNzaW5nL2ludmFsaWQgb3BlbmluZyBzdHJpbmcgJ3txdW90ZX0nIHRva2VuXCIsXG4gICAgbWlzc2luZ0Nsb3NlOiBcIk1pc3NpbmcvaW52YWxpZCBjbG9zaW5nIHN0cmluZyAne3F1b3RlfScgdG9rZW5cIixcbiAgICBtdXN0QmVXcmFwcGVkQnlRdW90ZXM6IFwiU3RyaW5ncyBtdXN0IGJlIHdyYXBwZWQgYnkgcXVvdGVzXCIsXG4gICAgbm9uQWxwaGFudW1lcmljOiBcIk5vbi1hbHBoYW51bWVyaWMgdG9rZW4gJ3t0b2tlbn0nIGlzIG5vdCBhbGxvd2VkIG91dHNpZGUgc3RyaW5nIG5vdGF0aW9uXCIsXG4gICAgdW5leHBlY3RlZEtleTogXCJVbmV4cGVjdGVkIGtleSBmb3VuZCBhdCBzdHJpbmcgcG9zaXRpb25cIlxuICB9LFxuICBrZXk6IHtcbiAgICBudW1iZXJBbmRMZXR0ZXJNaXNzaW5nUXVvdGVzOiBcIktleSBiZWdpbm5pbmcgd2l0aCBudW1iZXIgYW5kIGNvbnRhaW5pbmcgbGV0dGVycyBtdXN0IGJlIHdyYXBwZWQgYnkgcXVvdGVzXCIsXG4gICAgc3BhY2VNaXNzaW5nUXVvdGVzOiBcIktleSBjb250YWluaW5nIHNwYWNlIG11c3QgYmUgd3JhcHBlZCBieSBxdW90ZXNcIixcbiAgICB1bmV4cGVjdGVkU3RyaW5nOiBcIlVuZXhwZWN0ZWQgc3RyaW5nIGZvdW5kIGF0IGtleSBwb3NpdGlvblwiXG4gIH0sXG4gIG5vVHJhaWxpbmdPckxlYWRpbmdDb21tYTogXCJUcmFpbGluZyBvciBsZWFkaW5nIGNvbW1hcyBpbiBhcnJheXMgYW5kIG9iamVjdHMgYXJlIG5vdCBwZXJtaXR0ZWRcIlxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/locale/en.js\n");

/***/ }),

/***/ "./node_modules/react-json-editor-ajrm/node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _defineProperty; });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanM/YTQ1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/node_modules/@babel/runtime/helpers/esm/defineProperty.js\n");

/***/ }),

/***/ "./node_modules/react-json-editor-ajrm/node_modules/@babel/runtime/helpers/esm/objectSpread.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/node_modules/@babel/runtime/helpers/esm/objectSpread.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _objectSpread; });\n/* harmony import */ var _defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty */ \"./node_modules/react-json-editor-ajrm/node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      Object(_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]);\n    });\n  }\n\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWpzb24tZWRpdG9yLWFqcm0vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZC5qcz9mYmQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tIFwiLi9kZWZpbmVQcm9wZXJ0eVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-json-editor-ajrm/node_modules/@babel/runtime/helpers/esm/objectSpread.js\n");

/***/ })

}]);
//# sourceMappingURL=studio-bundle.js.map